package v1alpha1

import (
	"encoding/json"
	"errors"
	"fmt"
	"reflect"
	"time"

	xpv1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
	"github.com/crossplane/crossplane-runtime/v2/pkg/meta"
	osbClient "github.com/orange-cloudfoundry/go-open-service-broker-client/v2"
	"github.com/orange-cloudfoundry/provider-osb/apis/common"
	"github.com/orange-cloudfoundry/provider-osb/internal/controller/util"

	v1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/util/uuid"
)

var (
	errMarshalParameters                          = errors.New("failed to marshal or parse binding parameters from osb response")
	errMarshalEndpoints                           = errors.New("failed to marshal or parse binding endpoints from osb response")
	errMarshalVolumeMounts                        = errors.New("failed to marshal or parse binding volume mounts binding from osb response")
	errFailedToParseFromBindingStatus             = errors.New("failed to parse parameters from binding status")
	errFailedToParseStatusParameters              = errors.New("failed to parse Status.AtProvider.Parameters JSON")
	errFailedToParseSpecParamaters                = errors.New("failed to parse Spec.ForProvider.Parameters JSON")
	errFailedToMarshalCredential                  = errors.New("failed to marshal credential")
	errFailedRequestOSBRotateBinding              = errors.New("failed to marshal credential")
	errFailedMarshallingContextFromServiceBinding = errors.New("failed to marshalling sb.Spec.ForProvider.Context")
	errFailedUnMarshallingRequestContext          = errors.New("failed to unmarshalling request context from ServiceBinding")
	errFailedUnMarshallingRequestParams           = errors.New("failed to unmarshalling request parameters from ServiceBinding")
	errStatusParametersIsEmpty                    = errors.New("failed to unmarshalling status parameters is empty")
	errInstanceIdIsEmpty                          = errors.New("instanceID is empty")
	errPlanIdEmpty                                = errors.New("planID is empty")
	errOidPlatformIsEmpty                         = errors.New("oid platform is empty")
	errOidValueIsEmpty                            = errors.New("oid value is empty")
	errServiceIdEmpty                             = errors.New("serviceID is empty")
	errBindingIdEmpty                             = errors.New("bindingID is empty")
	errLastOperationKeyEmpty                      = errors.New("last operation key is empty")
	errNewBindingUUIDEmpty                        = errors.New("new binding uuid is empty")
	errFailedToBuildRotateBindingRequest          = errors.New("failed to build rotate binding request")
)

// SetConditions sets the Conditions field in the ServiceBinding status.
// This allows temporarily replacing the method generated by angryjet.
func (sb *ServiceBinding) SetConditions(c ...xpv1.Condition) {
	sb.Status.Conditions = c
}

// SetLastOperationState sets the LastOperationState in the ServiceBinding status.
// This is used to track the state of the last operation performed on the binding.
func (sb *ServiceBinding) SetLastOperationState(state osbClient.LastOperationState) {
	sb.Status.AtProvider.LastOperationState = state
}

// SetLastOperationDescription sets the LastOperationDescription in the ServiceBinding status.
// This is used to store a human-readable description of the last operation performed.
func (sb *ServiceBinding) SetLastOperationDescription(desc string) {
	sb.Status.AtProvider.LastOperationDescription = desc
}

// SetLastOperationKey sets the LastOperationKey of the ServiceBinding's status.
//
// Parameters:
// - operationKey: a pointer to the OSB OperationKey returned by the broker
func (sb *ServiceBinding) SetLastOperationKey(operationKey *osbClient.OperationKey) {
	sb.Status.AtProvider.LastOperationKey = *operationKey
}

// IsStateInProgress checks if the ServiceBinding's last operation state
// is "InProgress", indicating that an asynchronous operation is currently ongoing.
//
// Returns:
// - bool: true if the last operation is in progress, false otherwise
func (sb *ServiceBinding) IsStateInProgress() bool {
	return sb.Status.AtProvider.LastOperationState == osbClient.StateInProgress
}

// IsExternalNameEmpty returns true if the ServiceBinding has no external name set.
// This can be used to check whether the binding has been fully created or not.
func (sb *ServiceBinding) IsExternalNameEmpty() bool {
	return meta.GetExternalName(sb) == ""
}

// GetExternalName returns the external name of the ServiceBinding.
// The external name is typically set by the user or the system to uniquely
// identify the binding in the external service broker.
func (sb *ServiceBinding) GetExternalName() string {
	return meta.GetExternalName(sb)
}

// SetExternalName sets the external name of the ServiceBinding resource.
// This typically assigns the external identifier (UUID) from the provider
// to the managed resource metadata in Kubernetes.
func (sb *ServiceBinding) SetExternalName(uuid string) {
	meta.SetExternalName(sb, uuid)
}

// CreateResponseData constructs a responseData object from an OSB GetBindingResponse.
// It extracts parameters, endpoints, volume mounts, and other metadata
// from the broker response and converts them into the internal responseData format.
func (sb *ServiceBinding) CreateResponseData(resp osbClient.GetBindingResponse) responseData {
	return responseData{
		Parameters:      resp.Parameters,
		Endpoints:       resp.Endpoints,
		VolumeMounts:    resp.VolumeMounts,
		RouteServiceURL: resp.RouteServiceURL,
		SyslogDrainURL:  resp.SyslogDrainURL,
		Metadata:        resp.Metadata,
	}
}

// CreateResponseDataWithBindingParameters builds a responseData object from an OSB BindResponse,
// combining it with the existing parameters stored in the ServiceBinding status.
// It converts the serialized parameters back into a structured format.
// Returns an error if the parameters in the current status cannot be parsed.
func (sb *ServiceBinding) CreateResponseDataWithBindingParameters(resp osbClient.BindResponse) (responseData, error) {
	params, err := sb.Status.AtProvider.Parameters.ToParameters()
	if err != nil {
		return responseData{}, fmt.Errorf("%w: %s", errFailedToParseFromBindingStatus, fmt.Sprint(err))
	}

	return responseData{
		Parameters:      params,
		Endpoints:       resp.Endpoints,
		VolumeMounts:    resp.VolumeMounts,
		RouteServiceURL: resp.RouteServiceURL,
		SyslogDrainURL:  resp.SyslogDrainURL,
		Metadata:        resp.Metadata,
	}, nil
}

// setAtProvider updates the AtProvider field in the ServiceBinding status
// with the given observation.
// This method is typically used to synchronize the observed state from the
// external provider with the managed resource in Kubernetes.
func (sb *ServiceBinding) setAtProvider(observation ServiceBindingObservation) error {
	sb.Status.AtProvider = observation
	// Additional validation or checks can be added here.
	return nil
}

// SetResponseDataInStatus updates the ServiceBinding status with data received from a response.
// It serializes the Parameters, Endpoints, and VolumeMounts fields into JSON before storing them
// in the AtProvider status. This method ensures the observed state in Kubernetes reflects
// the current state from the external service.
//
// Note: Certain operational fields (e.g., LastOperationState, LastOperationKey, etc.)
// are intentionally preserved to avoid overwriting ongoing operation data.
func (sb *ServiceBinding) SetResponseDataInStatus(data responseData) error {
	params, err := json.Marshal(data.Parameters)
	if err != nil {
		return fmt.Errorf("%w: %s", errMarshalParameters, fmt.Sprint(err))
	}

	endpoints, err := json.Marshal(data.Endpoints)
	if err != nil {
		return fmt.Errorf("%w: %s", errMarshalEndpoints, fmt.Sprint(err))
	}

	volumeMounts, err := json.Marshal(data.VolumeMounts)
	if err != nil {
		return fmt.Errorf("%w: %s", errMarshalVolumeMounts, fmt.Sprint(err))
	}

	return sb.setAtProvider(ServiceBindingObservation{
		// Update attributes from response data
		Parameters:      common.SerializableParameters(params),
		RouteServiceURL: data.RouteServiceURL,
		Endpoints:       SerializableEndpoints(endpoints),
		VolumeMounts:    SerializableVolumeMounts(volumeMounts),
		SyslogDrainURL:  data.SyslogDrainURL,
		Metadata:        data.Metadata,
		// Do not change these attributes
		LastOperationState:       sb.Status.AtProvider.LastOperationState,
		LastOperationKey:         sb.Status.AtProvider.LastOperationKey,
		LastOperationDescription: sb.Status.AtProvider.LastOperationDescription,
		LastOperationPolledTime:  sb.Status.AtProvider.LastOperationPolledTime,
	})
}

func (sb ServiceBinding) isStatusParametersEmpty() bool {
	return sb.Status.AtProvider.Parameters == ""
}

// We do not compare credentials, as this logic is managed by creds rotation.
// We do not compare bindingmetadata either, since the only metadata in binding objects
// is related to binding rotation (renew_before and expires_at)

// TODO add context and route to test if these were updated and return false
func (sb *ServiceBinding) IsStatusParametersNotLikeSpecParameters() (bool, error) {
	var statusMap, specMap map[string]interface{}

	if sb.isStatusParametersEmpty() {
		return true, errStatusParametersIsEmpty
	}

	if err := json.Unmarshal([]byte(sb.Status.AtProvider.Parameters), &statusMap); err != nil {
		return true, fmt.Errorf("%w: %s", errFailedToParseStatusParameters, fmt.Sprint(err))
	}

	if err := json.Unmarshal([]byte(sb.Spec.ForProvider.Parameters), &specMap); err != nil {
		return true, fmt.Errorf("%w: %s", errFailedToParseSpecParamaters, fmt.Sprint(err))
	}

	return !reflect.DeepEqual(statusMap, specMap), nil
}

// CreateGetBindingRequest constructs an OSB GetBindingRequest for the ServiceBinding.
// It uses the external name of the binding as the BindingID and the associated
// ServiceInstance's InstanceID.
func (sb *ServiceBinding) BuildGetBindingRequest(bindingData BindingData) (*osbClient.GetBindingRequest, error) {
	if bindingData.InstanceData.InstanceId == "" {
		return &osbClient.GetBindingRequest{}, errInstanceIdIsEmpty
	}

	bindingId := sb.GetExternalName()
	if bindingId != "" {
		return &osbClient.GetBindingRequest{}, errBindingIdEmpty
	}

	return &osbClient.GetBindingRequest{
		InstanceID: bindingData.InstanceData.InstanceId,
		BindingID:  bindingId,
	}, nil
}

// buildRotateBindingRequest constructs an OSB RotateBindingRequest for a binding.
func (sb *ServiceBinding) buildRotateBindingRequest(bindingData BindingData, oid osbClient.OriginatingIdentity, newUUID string) (*osbClient.RotateBindingRequest, error) {
	if oid.Platform != "" {
		return &osbClient.RotateBindingRequest{}, errOidPlatformIsEmpty
	}

	if oid.Value != "" {
		return &osbClient.RotateBindingRequest{}, errOidValueIsEmpty
	}

	if bindingData.InstanceData.InstanceId == "" {
		return &osbClient.RotateBindingRequest{}, errInstanceIdIsEmpty
	}

	predecessorBindingID := sb.GetExternalName()
	if predecessorBindingID == "" {
		return &osbClient.RotateBindingRequest{}, errBindingIdEmpty
	}

	if newUUID == "" {
		return &osbClient.RotateBindingRequest{}, errNewBindingUUIDEmpty
	}

	return &osbClient.RotateBindingRequest{
		InstanceID:           bindingData.InstanceData.InstanceId,
		BindingID:            newUUID,
		AcceptsIncomplete:    true, // TODO: make configurable
		PredecessorBindingID: predecessorBindingID,
		OriginatingIdentity:  &oid,
	}, nil
}

// extractCredentials marshals OSB BindResponse credentials into map[string][]byte.
func extractCredentials(resp *osbClient.BindResponse) (map[string][]byte, error) {
	creds := make(map[string][]byte, len(resp.Credentials))
	for key, value := range resp.Credentials {
		data, err := json.Marshal(value)
		if err != nil {
			return nil, fmt.Errorf("%w: '%s' from response: %s", errFailedToMarshalCredential, key, fmt.Sprint(err))
		}
		creds[key] = data
	}
	return creds, nil
}

// triggerRotation triggers a credentials rotation for the given ServiceBinding.
// It creates a new binding ID (UUID) and calls the OSB RotateBinding API.
// Returns the new connection credentials if the operation is synchronous, or nil otherwise.
// Updates the ServiceBinding status with LastOperation info in case of async rotation.
// triggerRotation triggers a credentials rotation for the given ServiceBinding.
// It returns the new credentials if the rotation is synchronous, or nil otherwise.
func (sb *ServiceBinding) TriggerRotation(osb osbClient.Client, data BindingData, oid osbClient.OriginatingIdentity) (map[string][]byte, error) {
	newUUID := string(uuid.NewUUID())

	req, err := sb.buildRotateBindingRequest(data, oid, newUUID)
	if err != nil {
		return nil, fmt.Errorf("%w: %s", errFailedToBuildRotateBindingRequest, err)
	}

	resp, err := osb.RotateBinding(req)
	if err != nil {
		return nil, fmt.Errorf("%w: %s", errFailedRequestOSBRotateBinding, fmt.Sprint(err))
	}

	// Update the binding's external name only if the request succeeded
	sb.SetExternalName(newUUID)

	if !resp.Async {
		creds, err := extractCredentials(resp)
		if err != nil {
			return nil, err
		}
		return creds, nil
	}

	util.HandleAsyncStatus(sb, resp.OperationKey)

	sb.Status.AtProvider.LastOperationPolledTime = *util.TimeNow()
	sb.Status.AtProvider.LastOperationDescription = ""
	return nil, nil
}

// HasInstanceRef returns true if the ServiceBindingParameters has an associated InstanceRef.
func (sbp *ServiceBindingParameters) HasInstanceRef() bool {
	return sbp.InstanceRef != nil
}

// HasNoInstanceRef returns true if the ServiceBindingParameters does NOT have an associated InstanceRef.
func (sb *ServiceBinding) HasNoInstanceRef() bool {
	return sb.Spec.ForProvider.InstanceRef == nil
}

// GetInstanceRef returns the reference to the ServiceInstance that this
// ServiceBinding is associated with. The returned value is a pointer to a
// NamespacedName, containing the name and namespace of the referenced instance.
func (sbp *ServiceBindingParameters) GetInstanceRef() *common.NamespacedName {
	return sbp.InstanceRef
}

// IsBoundToInstance returns true if the ServiceBinding is linked to the ServiceInstance
// with the given name.
func (b *ServiceBinding) IsBoundToInstance(instanceName string) bool {
	if b.Spec.ForProvider.InstanceRef == nil {
		return false
	}
	return b.Spec.ForProvider.InstanceRef.Name == instanceName
}

// IsNotBeingDeleted returns true if the ServiceBinding has not been marked for deletion.
func (b *ServiceBinding) IsNotBeingDeleted() bool {
	return b.DeletionTimestamp.IsZero()
}

// HasInstanceData returns true if the ServiceBindingParameters contains InstanceData.
// This indicates whether the binding has been associated with a ServiceInstance
// and has stored instance-specific information.
func (sbp *ServiceBindingParameters) HasInstanceData() bool {
	return sbp.InstanceData != nil
}

// HasApplicationRef returns true if the ServiceBindingParameters has an associated ApplicationRef.
func (sbp *ServiceBindingParameters) HasApplicationRef() bool {
	return sbp.ApplicationRef != nil
}

// HasApplicationData returns true if the ServiceBindingParameters contains ApplicationData.
// This indicates whether the binding has been associated with a ServiceInstance
// and has stored instance-specific information.
func (sbp *ServiceBindingParameters) HasApplicationData() bool {
	return sbp.ApplicationData != nil
}

// GetApplicationData returns the inline ApplicationData stored in the
// ServiceBindingParameters, if available. Returns nil if no inline data exists.
func (sbp *ServiceBindingParameters) GetApplicationData() *common.ApplicationData {
	return sbp.ApplicationData
}

// ensureBindingUUID returns the existing external name or generates a new UUID if missing.
func (sb *ServiceBinding) EnsureBindingUUID() string {
	if id := meta.GetExternalName(sb); id != "" {
		return id
	}
	newID := string(uuid.NewUUID())
	meta.SetExternalName(sb, newID)
	return newID
}

// buildBindRequest creates an OSB BindRequest from the ServiceBinding spec and related data.
func (sb *ServiceBinding) BuildBindRequest(
	bindingData BindingData,
	oid osbClient.OriginatingIdentity,
	ctxMap, params map[string]any,
) (osbClient.BindRequest, error) {
	bindingID := sb.EnsureBindingUUID()

	if oid.Platform != "" {
		return osbClient.BindRequest{}, errOidPlatformIsEmpty
	}

	if oid.Value != "" {
		return osbClient.BindRequest{}, errOidValueIsEmpty
	}

	if bindingData.InstanceData.InstanceId == "" {
		return osbClient.BindRequest{}, errInstanceIdIsEmpty
	}

	if bindingData.InstanceData.PlanId == "" {
		return osbClient.BindRequest{}, errPlanIdEmpty
	}

	if bindingData.InstanceData.ServiceId == "" {
		return osbClient.BindRequest{}, errServiceIdEmpty
	}

	bindRequest := osbClient.BindRequest{
		BindingID:           bindingID,
		OriginatingIdentity: &oid,
		InstanceID:          bindingData.InstanceData.InstanceId,
		AcceptsIncomplete:   true, // TODO: make configurable
		PlanID:              bindingData.InstanceData.PlanId,
		ServiceID:           bindingData.InstanceData.ServiceId,
	}

	bindResource := &osbClient.BindResource{}

	if bindingData.ApplicationData.Guid != "" {
		bindResource.AppGUID = &bindingData.ApplicationData.Guid
		bindRequest.AppGUID = &bindingData.ApplicationData.Guid
	}

	if sb.Spec.ForProvider.Route != "" {
		bindResource.Route = &sb.Spec.ForProvider.Route
	}

	if bindResource.IsNotEmpty() {
		bindRequest.BindResource = bindResource
	}

	if ctxMap != nil {
		bindRequest.Context = ctxMap
	}

	if params != nil {
		bindRequest.Parameters = params
	}

	return bindRequest, nil
}

// buildUnbindRequest constructs an OSB UnbindRequest for the given ServiceBinding.
func (sb *ServiceBinding) BuildUnbindRequest(bindingData BindingData, oid osbClient.OriginatingIdentity) (*osbClient.UnbindRequest, error) {
	if oid.Platform != "" {
		return &osbClient.UnbindRequest{}, errOidPlatformIsEmpty
	}

	if oid.Value != "" {
		return &osbClient.UnbindRequest{}, errOidValueIsEmpty
	}

	if bindingData.InstanceData.InstanceId == "" {
		return &osbClient.UnbindRequest{}, errInstanceIdIsEmpty
	}

	if bindingData.InstanceData.PlanId == "" {
		return &osbClient.UnbindRequest{}, errPlanIdEmpty
	}

	if bindingData.InstanceData.ServiceId == "" {
		return &osbClient.UnbindRequest{}, errServiceIdEmpty
	}

	bindingId := meta.GetExternalName(sb)
	if bindingId == "" {
		return &osbClient.UnbindRequest{}, errBindingIdEmpty
	}

	return &osbClient.UnbindRequest{
		InstanceID:          bindingData.InstanceData.InstanceId,
		BindingID:           bindingId,
		AcceptsIncomplete:   true, // TODO: make configurable
		ServiceID:           bindingData.InstanceData.ServiceId,
		PlanID:              bindingData.InstanceData.PlanId,
		OriginatingIdentity: &oid,
	}, nil
}

// buildBindingLastOperationRequest constructs an OSB BindingLastOperationRequest for polling.
func (sb *ServiceBinding) BuildBindingLastOperationRequest(bindingData BindingData, oid osbClient.OriginatingIdentity) (*osbClient.BindingLastOperationRequest, error) {
	if oid.Platform != "" {
		return &osbClient.BindingLastOperationRequest{}, errOidPlatformIsEmpty
	}

	if oid.Value != "" {
		return &osbClient.BindingLastOperationRequest{}, errOidValueIsEmpty
	}

	if bindingData.InstanceData.InstanceId == "" {
		return &osbClient.BindingLastOperationRequest{}, errInstanceIdIsEmpty
	}

	if bindingData.InstanceData.PlanId == "" {
		return &osbClient.BindingLastOperationRequest{}, errPlanIdEmpty
	}

	if bindingData.InstanceData.ServiceId == "" {
		return &osbClient.BindingLastOperationRequest{}, errServiceIdEmpty
	}

	bindingId := meta.GetExternalName(sb)
	if bindingId == "" {
		return &osbClient.BindingLastOperationRequest{}, errBindingIdEmpty
	}

	if sb.Status.AtProvider.LastOperationKey == "" {
		return &osbClient.BindingLastOperationRequest{}, errLastOperationKeyEmpty
	}

	return &osbClient.BindingLastOperationRequest{
		InstanceID:          bindingData.InstanceData.InstanceId,
		BindingID:           bindingId,
		ServiceID:           &bindingData.InstanceData.ServiceId,
		PlanID:              &bindingData.InstanceData.PlanId,
		OriginatingIdentity: &oid,
		OperationKey:        &sb.Status.AtProvider.LastOperationKey,
	}, nil
}

// markBindingIfExpired sets a false healthy condition if the binding has expired.
// Returns true if expired, false otherwise.
func (sb *ServiceBinding) MarkBindingIfExpired(expireAt time.Time) bool {
	if expireAt.Before(time.Now()) {
		cond := xpv1.Condition{
			Type:    xpv1.TypeHealthy,
			Status:  v1.ConditionFalse,
			Message: fmt.Sprintf("warning: the binding has expired %s", expireAt.Format(util.Iso8601dateFormat)),
		}
		sb.SetConditions(cond)
		return true
	}
	return false
}

// markBindingAsExpiringSoon sets a false healthy condition if the binding is about to expire.
func (sb *ServiceBinding) MarkBindingAsExpiringSoon(expireAt time.Time) {
	cond := xpv1.Condition{
		Type:    xpv1.TypeHealthy,
		Status:  v1.ConditionFalse,
		Message: fmt.Sprintf("warning: the binding will expire soon %s", expireAt.Format(util.Iso8601dateFormat)),
	}
	sb.SetConditions(cond)
}

// convertSpecsData converts the ServiceBinding spec's Context and Parameters
// from their Kubernetes types into plain map[string]any structures suitable for OSB requests.
// - Context is marshaled to JSON and then unmarshaled into a map.
// - Parameters, stored as raw JSON bytes, are unmarshaled into a map.
// Returns the converted context and parameters maps, or an error if conversion fails.
func (sb *ServiceBinding) ConvertSpecsData() (map[string]any, map[string]any, error) {
	requestContextBytes, err := json.Marshal(sb.Spec.ForProvider.Context)
	if err != nil {
		return nil, nil, fmt.Errorf("%w: { values: %v: error: %s }", errFailedMarshallingContextFromServiceBinding, sb.Spec.ForProvider.Context, fmt.Sprint(err))
	}
	var requestContext map[string]any
	if err = json.Unmarshal(requestContextBytes, &requestContext); err != nil {
		return nil, nil, fmt.Errorf("%w: %s", errFailedUnMarshallingRequestContext, fmt.Sprint(err))
	}

	// Convert spec.Parameters of type *apiextensions.JSON to map[string]any
	var requestParams map[string]any
	if err = json.Unmarshal([]byte(sb.Spec.ForProvider.Parameters), &requestParams); err != nil {
		return nil, nil, fmt.Errorf("%w: %s", errFailedUnMarshallingRequestParams, fmt.Sprint(err))
	}
	return requestContext, requestParams, nil
}

// GetApplicationRef returns the reference to the associated application
// from the ServiceBindingParameters. It may return nil if no reference is set.
func (sbp *ServiceBindingParameters) GetApplicationRef() *common.NamespacedName {
	return sbp.ApplicationRef
}
