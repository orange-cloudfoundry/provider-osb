package v1alpha1

import (
	"context"
	"errors"
	"fmt"
	"reflect"

	xpv1 "github.com/crossplane/crossplane-runtime/v2/apis/common"
	osbClient "github.com/orange-cloudfoundry/go-open-service-broker-client/v2"
	"github.com/orange-cloudfoundry/provider-osb/apis/common"
	"github.com/orange-cloudfoundry/provider-osb/internal/controller/util"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
)

var (
	errFailedToParseServiceInstanceParameters    = errors.New("error while marshalling or parsing parameters to bytes from ServiceInstance")
	errFailedToMarshallServiceInstanceParameters = errors.New("failed to marshal ServiceInstance parameters")
	errFailedToMarshallServiceInstanceContext    = errors.New("failed to marshal ServiceInstance context")
	errInstanceIdIsEmpty                         = errors.New("instanceID is empty")
	errPlanIdEmpty                               = errors.New("planID is empty")
	errServiceIdEmpty                            = errors.New("serviceID is empty")
	errOrganizationGuidEmpty                     = errors.New("organizationGuid is empty")
	errSpaceGuidEmpty                            = errors.New("spaceGuid is empty")
	errCtxMapEmpty                               = errors.New("ctxMap is empty")
	errOidPlatformIsEmpty                        = errors.New("oid platform is empty")
	errOidValueIsEmpty                           = errors.New("oid value is empty")
	errFailedToBuildPollLastOperationRequest     = errors.New("failed to build poll last operation request")
	errFailedToBuildDeprovisionRequest           = errors.New("failed to build deprovision request")
	errOSBDeprovisionInstanceFailed              = errors.New("OSB DeprovisionInstance request failed")
	errCannotUpdateServiceInstanceStatus         = errors.New("cannot update ServiceInstance status")
	errFailedToGetLastestKubeObject              = errors.New("failed to get latest kubernetes object")
	errOSBPollLastOperationFailed                = errors.New("OSB PollLastOperation request failed")
	errFailedToRemoveFinalizer                   = errors.New("failed to remove finalizer")
	errParseParametersFailed                     = errors.New("failed to parse ServiceInstance parameters")
	errCannotDeleteWithActiveBindings            = errors.New("cannot delete ServiceInstance, it has active bindings")
	errParseContextFailed                        = errors.New("failed to parse ServiceInstance context")
	errFailedToBuildProvisionRequest             = errors.New("failed to build provision request")
	errOSBProvisionInstanceFailed                = errors.New("OSB ProvisionInstance request failed")
	errCannotBuildUpdateRequest                  = errors.New("cannot build update request")
	errOSBUpdateInstanceFailed                   = errors.New("OSB UpdateInstance request failed")
	errFailedToHandleLastOperationInProgress     = errors.New("failed to handle last operation in progress")
	errFailedToHandleDeletionWithActiveBindings  = errors.New("failed to handle deletion with active bindings")
	errOSBGetInstance                            = errors.New("OSB GetInstance request failed")
	errFailedToCompareSpecWithOSB                = errors.New("failed to compare spec with osb")
	errFailedToBuildGetInstanceRequest           = errors.New("failed to build get instance request")
)

// SetConditions sets the Conditions field in the ServiceInstance status.
// This allows temporarily replacing the method generated by angryjet.
func (sb *ServiceInstance) SetConditions(c ...xpv1.Condition) {
	sb.Status.Conditions = c
}

// GetProviderConfigReference of this ServiceInstance.
func (si *ServiceInstance) GetProviderConfigReference() *xpv1.ProviderConfigReference {
	if si.Spec.ForProvider.ApplicationData == nil {
		return nil
	}

	return si.Spec.ForProvider.ApplicationData.ProviderConfigReference
}

// SetLastOperationState sets the LastOperationState in the ServiceInstance status.
// This is used to track the state of the last operation performed on the instance.
func (si *ServiceInstance) SetLastOperationState(state osbClient.LastOperationState) {
	si.Status.AtProvider.LastOperationState = state
}

// SetLastOperationDescription sets the LastOperationDescription in the ServiceInstance status.
// This is used to store a human-readable description of the last operation performed.
func (si *ServiceInstance) SetLastOperationDescription(desc string) {
	si.Status.AtProvider.LastOperationDescription = desc
}

// SetLastOperationKey sets the LastOperationKey of the ServiceInstance's status.
//
// Parameters:
// - operationKey: a pointer to the OSB OperationKey returned by the broker
func (si *ServiceInstance) SetLastOperationKey(operationKey osbClient.OperationKey) {
	si.Status.AtProvider.LastOperationKey = operationKey
}

// IsDeletable returns true if the ServiceInstance is in deleting state
// and has no active bindings.
func (si *ServiceInstance) IsDeletable() bool {
	return si.Status.AtProvider.LastOperationState == osbClient.StateDeleting &&
		!si.Status.AtProvider.HasActiveBindings
}

// IsStateInProgress checks if the ServiceInstance's last operation state
// is "InProgress", indicating that an asynchronous operation is currently ongoing.
//
// Returns:
// - bool: true if the last operation is in progress, false otherwise
func (si *ServiceInstance) IsStateInProgress() bool {
	return si.Status.AtProvider.LastOperationState == osbClient.StateInProgress
}

// IsStateDeleting checks if the ServiceInstance's last operation state
// indicates that the instance is being deleted.
//
// Returns:
// - bool: true if the last operation state is "deleting", false otherwise
func (si *ServiceInstance) IsStateDeleting() bool {
	return si.Status.AtProvider.LastOperationState == osbClient.StateDeleting
}

// IsAlreadyDeleted checks if the given ServiceInstance has no InstanceId set,
// indicating that the resource does not exist in the external system and can be
// considered already deleted.
//
// Parameters:
// - instance: the ServiceInstance to check
//
// Returns:
// - bool: true if the instance is considered already deleted, false otherwise
func (si *ServiceInstance) IsAlreadyDeleted() bool {
	// If the InstanceId is empty, the resource does not exist externally
	return si.Spec.ForProvider.InstanceId == ""
}

// HasActiveBindings checks if the ServiceInstance currently has active bindings.
//
// If true, the ServiceInstance cannot be deleted because bindings are still referencing it.
//
// Returns:
// - bool: true if there are active bindings, false otherwise
func (si *ServiceInstance) HasActiveBindings() bool {
	return si.Status.AtProvider.HasActiveBindings
}

// HasPlanID checks if the ServiceInstance has a PlanID set.
//
// Returns:
// - bool: true if PlanID is not empty, false otherwise
func (si *ServiceInstance) HasPlanID() bool {
	return si.Spec.ForProvider.PlanId != ""
}

// IsPlanIDDifferent checks if the ServiceInstance's PlanID is different
// from the PlanID of the given OSB instance.
//
// Parameters:
// - osbPlanID: the PlanID from the OSB instance to compare against
//
// Returns:
// - bool: true if PlanIDs are different, false if they match
func (si *ServiceInstance) IsPlanIDDifferent(osbPlanID string) bool {
	return si.Spec.ForProvider.PlanId != osbPlanID
}

// compareParametersWithOSB compares parameters between a ServiceInstance spec
// and its OSB instance response.
func (si *ServiceInstance) compareParametersWithOSB(osbInstance *osbClient.GetInstanceResponse) (common.Action, error) {
	if len(si.Spec.ForProvider.Parameters) == 0 {
		return common.NeedToUpdate, nil
	}

	params, err := si.Spec.ForProvider.Parameters.ToParameters()
	if err != nil {
		return common.NothingToDo, fmt.Errorf("%w: %s", errFailedToParseServiceInstanceParameters, fmt.Sprint(err))
	}

	if !reflect.DeepEqual(params, osbInstance.Parameters) {
		return common.NeedToUpdate, nil
	}

	return common.NothingToDo, nil
}

// CompareSpecWithOSB compares a ServiceInstance spec with the corresponding OSB instance response.
// It returns true if both representations are consistent, false otherwise.
func (si *ServiceInstance) CompareSpecWithOSB(osbInstance *osbClient.GetInstanceResponse) (common.Action, error) {
	if osbInstance == nil {
		return common.NothingToDo, nil
	}

	// Compare PlanID
	if si.HasPlanID() && si.IsPlanIDDifferent(osbInstance.PlanID) {
		return common.NothingToDo, nil
	}

	// Compare parameters
	if action, err := si.compareParametersWithOSB(osbInstance); err != nil || common.NeedToUpdate == action {
		return action, err
	}

	// Compare context
	if !reflect.DeepEqual(si.Spec.ForProvider.Context, si.Status.AtProvider.Context) {
		return common.NeedToUpdate, nil
	}

	return common.NothingToDo, nil
}

// BuildProvisionRequest creates an OSB ProvisionRequest from a ServiceInstance spec.
func (si *ServiceInstance) buildProvisionRequest(params map[string]any, ctxMap map[string]any) (*osbClient.ProvisionRequest, error) {
	if si.Spec.ForProvider.InstanceId == "" {
		return &osbClient.ProvisionRequest{}, errInstanceIdIsEmpty
	}

	if si.Spec.ForProvider.PlanId == "" {
		return &osbClient.ProvisionRequest{}, errPlanIdEmpty
	}

	if si.Spec.ForProvider.ServiceId == "" {
		return &osbClient.ProvisionRequest{}, errServiceIdEmpty
	}

	if si.Spec.ForProvider.OrganizationGuid == "" {
		return &osbClient.ProvisionRequest{}, errOrganizationGuidEmpty
	}

	if si.Spec.ForProvider.SpaceGuid == "" {
		return &osbClient.ProvisionRequest{}, errSpaceGuidEmpty
	}

	if len(ctxMap) == 0 {
		return &osbClient.ProvisionRequest{}, errCtxMapEmpty
	}

	provisionRequest := &osbClient.ProvisionRequest{
		InstanceID:        si.Spec.ForProvider.InstanceId,
		ServiceID:         si.Spec.ForProvider.ServiceId,
		PlanID:            si.Spec.ForProvider.PlanId,
		OrganizationGUID:  si.Spec.ForProvider.OrganizationGuid,
		SpaceGUID:         si.Spec.ForProvider.SpaceGuid,
		AcceptsIncomplete: true,
		Context:           ctxMap,
	}

	if params != nil {
		provisionRequest.Parameters = params
	}

	return provisionRequest, nil
}

// buildUpdateInstanceRequest constructs an OSB UpdateInstanceRequest from the given ServiceInstance.
// It converts the ServiceInstance spec parameters and context into the format expected by the OSB client.
// Returns the prepared request or an error if the conversion fails.
func (si *ServiceInstance) buildUpdateInstanceRequest(oid osbClient.OriginatingIdentity) (*osbClient.UpdateInstanceRequest, error) {
	params, err := si.Spec.ForProvider.Parameters.ToParameters()
	if err != nil {
		return nil, fmt.Errorf("%w: %s", errFailedToMarshallServiceInstanceParameters, fmt.Sprint(err))
	}

	ctxMap, err := si.Spec.ForProvider.Context.ToMap()
	if err != nil {
		return nil, fmt.Errorf("%w: %s", errFailedToMarshallServiceInstanceContext, fmt.Sprint(err))
	}

	if si.Spec.ForProvider.InstanceId == "" {
		return &osbClient.UpdateInstanceRequest{}, errInstanceIdIsEmpty
	}

	if si.Spec.ForProvider.ServiceId == "" {
		return &osbClient.UpdateInstanceRequest{}, errServiceIdEmpty
	}

	if oid.Platform == "" {
		return &osbClient.UpdateInstanceRequest{}, errOidPlatformIsEmpty
	}

	if oid.Value == "" {
		return &osbClient.UpdateInstanceRequest{}, errOidValueIsEmpty
	}

	updateInstanceRequest := &osbClient.UpdateInstanceRequest{
		InstanceID:          si.Spec.ForProvider.InstanceId,
		ServiceID:           si.Spec.ForProvider.ServiceId,
		AcceptsIncomplete:   true,
		OriginatingIdentity: &oid,
	}
	// TODO oid

	if si.Spec.ForProvider.PlanId != "" {
		updateInstanceRequest.PlanID = &si.Spec.ForProvider.PlanId
	}

	if len(ctxMap) > 0 {
		updateInstanceRequest.Context = ctxMap
	}

	if params != nil {
		updateInstanceRequest.Parameters = params
	}

	return updateInstanceRequest, nil
}

// updateStatus updates the ServiceInstance status based on the OSB ProvisionInstance response.
func (si *ServiceInstance) UpdateStatus(resp *osbClient.ProvisionResponse) {
	si.Status.AtProvider.Context = si.Spec.ForProvider.Context
	si.Status.AtProvider.DashboardURL = resp.DashboardURL

	if resp.Async {
		si.Status.SetConditions(xpv1.Creating())
		si.Status.AtProvider.LastOperationState = osbClient.StateInProgress
		if resp.OperationKey != nil {
			si.Status.AtProvider.LastOperationKey = *resp.OperationKey
		}
		return
	}

	si.Status.SetConditions(xpv1.Available())
	si.Status.AtProvider.LastOperationState = osbClient.StateSucceeded
}

// SetStatusContextFromProviderContext copies the context from the ServiceInstance's
// spec (ForProvider) into its status (AtProvider). This keeps the observed state
// in sync with the desired configuration.
func (si *ServiceInstance) SetStatusContextFromProviderContext() {
	si.Status.AtProvider.Context = si.Spec.ForProvider.Context
}

// SetDashboardURL updates the ServiceInstance status with the provided dashboard URL.
// This method is typically called after receiving a response from the service broker.
func (si *ServiceInstance) SetDashboardURL(url *string) {
	si.Status.AtProvider.DashboardURL = url
}

// updateInstanceStatusFromUpdate updates the status of the ServiceInstance
// based on the OSB UpdateInstanceResponse. It sets the dashboard URL, context,
// and last operation state. If the update is asynchronous, it also sets the
// last operation key and marks the operation as in progress.
func (si *ServiceInstance) UpdateStatusFromOSB(resp osbClient.OSBAsyncResponse) {
	si.SetStatusContextFromProviderContext()
	si.SetDashboardURL(resp.GetDashboardURL())

	if resp.IsAsync() {
		si.Status.SetConditions(xpv1.Creating())
		si.SetLastOperationState(osbClient.StateInProgress)
		if resp.GetOperationKey() != nil {
			si.SetLastOperationKey(*resp.GetOperationKey())
		}
		return
	}

	si.Status.SetConditions(xpv1.Available())
	si.SetLastOperationState(osbClient.StateSucceeded)
}

// IsInstanceIDEmpty returns true if the ServiceInstance has no InstanceId set
// in its spec. This can be used to check whether the instance has been
// provisioned or not.
func (si *ServiceInstance) IsInstanceIDEmpty() bool {
	return si.Spec.ForProvider.InstanceId == ""
}

// createRequestPollLastOperation builds and returns an OSB LastOperationRequest
// for polling the current status of an asynchronous operation on a service mg.
func (si *ServiceInstance) BuildPollLastOperationRequest(oid osbClient.OriginatingIdentity) (*osbClient.LastOperationRequest, error) {
	if si.Spec.ForProvider.InstanceId == "" {
		return &osbClient.LastOperationRequest{}, errInstanceIdIsEmpty
	}

	if oid.Platform == "" {
		return &osbClient.LastOperationRequest{}, errOidPlatformIsEmpty
	}

	if oid.Value == "" {
		return &osbClient.LastOperationRequest{}, errOidValueIsEmpty
	}

	lastOperationRequest := &osbClient.LastOperationRequest{
		InstanceID:          si.Spec.ForProvider.InstanceId,
		OriginatingIdentity: &oid,
	}

	if si.Spec.ForProvider.ServiceId != "" {
		lastOperationRequest.ServiceID = &si.Spec.ForProvider.ServiceId
	}

	if si.Spec.ForProvider.PlanId != "" {
		lastOperationRequest.PlanID = &si.Spec.ForProvider.PlanId
	}

	if si.Status.AtProvider.LastOperationKey != "" {
		lastOperationRequest.OperationKey = &si.Status.AtProvider.LastOperationKey
	}

	return lastOperationRequest, nil
}

// updateInstanceStatusForAsyncDeletion updates the ServiceInstance status when
// a deletion is performed asynchronously.
func (si *ServiceInstance) UpdateStatusForAsyncDeletion(resp *osbClient.DeprovisionResponse) {
	si.SetLastOperationState(osbClient.StateDeleting)
	if resp.OperationKey != nil {
		si.SetLastOperationKey(*resp.OperationKey)
	}
}

// buildDeprovisionRequest constructs an OSB DeprovisionRequest from a ServiceInstance.
func (si *ServiceInstance) buildDeprovisionRequest(oid osbClient.OriginatingIdentity) (*osbClient.DeprovisionRequest, error) {
	if si.Spec.ForProvider.InstanceId == "" {
		return &osbClient.DeprovisionRequest{}, errInstanceIdIsEmpty
	}

	if si.Spec.ForProvider.ServiceId == "" {
		return &osbClient.DeprovisionRequest{}, errServiceIdEmpty
	}

	if si.Spec.ForProvider.PlanId == "" {
		return &osbClient.DeprovisionRequest{}, errPlanIdEmpty
	}

	if oid.Platform == "" {
		return &osbClient.DeprovisionRequest{}, errOidPlatformIsEmpty
	}

	if oid.Value == "" {
		return &osbClient.DeprovisionRequest{}, errOidValueIsEmpty
	}

	return &osbClient.DeprovisionRequest{
		InstanceID:          si.Spec.ForProvider.InstanceId,
		ServiceID:           si.Spec.ForProvider.ServiceId,
		PlanID:              si.Spec.ForProvider.PlanId,
		AcceptsIncomplete:   true,
		OriginatingIdentity: &oid,
	}, nil
}

// GetSpecForProvider returns a copy of the ForProvider spec.
// Useful for read-only operations or when you do not want to modify the original.
func (si *ServiceInstance) GetSpecForProvider() common.InstanceData {
	return si.Spec.ForProvider
}

// GetSpecForProviderPtr returns a pointer to the ForProvider spec.
// Useful for passing to functions that expect a pointer receiver
// or an interface implemented on *InstanceData.
func (si *ServiceInstance) GetSpecForProviderPtr() *common.InstanceData {
	return &si.Spec.ForProvider
}

// deprovision handles the deprovisioning of a ServiceInstance in the external system.
// It returns an ExternalDelete indicating whether the resource still exists or not.
func (si *ServiceInstance) Deprovision(ctx context.Context, kube client.Client, osb osbClient.Client, oid osbClient.OriginatingIdentity) error {
	// If the InstanceId is not set, there is nothing to delete.
	// We consider the resource as already deleted.
	if si.IsInstanceIDEmpty() {
		return nil
	}
	if si.IsAlreadyDeleted() {
		return nil
	}
	// If there are active bindings, we cannot delete the ServiceInstance.
	if si.HasActiveBindings() {
		return errCannotDeleteWithActiveBindings
	}
	req, err := si.buildDeprovisionRequest(oid)
	if err != nil {
		return fmt.Errorf("%w: %s", errFailedToBuildDeprovisionRequest, fmt.Sprint(err))
	}

	resp, err := osb.DeprovisionInstance(req)
	if err != nil {
		if util.IsResourceGone(err) {
			// Resource is already gone; nothing to do.
			return nil
		}
		return fmt.Errorf("%w: %s", errOSBDeprovisionInstanceFailed, fmt.Sprint(err))
	}

	if resp.Async {
		// Asynchronous deletion: update last operation status
		si.UpdateStatusForAsyncDeletion(resp)
		// Persist status to Kubernetes
		if err := kube.Status().Update(ctx, si); err != nil {
			return fmt.Errorf("%w: %s", errCannotUpdateServiceInstanceStatus, fmt.Sprint(err))
		}
	}

	return nil
}

// removeFinalizer removes the specified finalizer from the ServiceInstance if it exists.
func (si *ServiceInstance) removeFinalizer(ctx context.Context, kube client.Client) error {
	latest, err := util.GetLatestKubeObject(ctx, kube, si)
	if err != nil {
		return fmt.Errorf("%w: %s", errFailedToGetLastestKubeObject, fmt.Sprint(err))
	}

	// Remove the specified finalizer if it exists.
	for _, f := range latest.GetFinalizers() {
		controllerutil.RemoveFinalizer(latest, f)
	}

	// Update the status of the ServiceInstance resource in Kubernetes.
	if err := kube.Status().Update(ctx, latest); err != nil {
		return fmt.Errorf("%w: %s", errCannotUpdateServiceInstanceStatus, fmt.Sprint(err))
	}

	return nil
}

// Build the LastOperationRequest using the InstanceId and LastOperationKey from the ServiceInstance status.
func (si *ServiceInstance) HandleLastOperationInProgress(ctx context.Context, kube client.Client, osb osbClient.Client, oid osbClient.OriginatingIdentity) (common.Action, error) {
	req, err := si.BuildPollLastOperationRequest(oid)
	if err != nil {
		return common.NothingToDo, fmt.Errorf("%w: %s", errFailedToBuildPollLastOperationRequest, fmt.Sprint(err))
	}

	resp, err := osb.PollLastOperation(req)

	if err != nil {
		if util.IsResourceGone(err) {
			return common.NeedToCreate, nil
		}
		// Other errors are unexpected
		return common.NothingToDo, fmt.Errorf("%w: %s", errOSBPollLastOperationFailed, fmt.Sprint(err))
	}

	latest, err := util.GetLatestKubeObject(ctx, kube, si)
	if err != nil {
		return common.NothingToDo, fmt.Errorf("%w: %s", errFailedToGetLastestKubeObject, fmt.Sprint(err))
	}

	util.UpdateStatusFromLastOp(latest, resp)

	if si.IsDeletable() {
		if err := si.removeFinalizer(ctx, kube); err != nil {
			return common.NothingToDo, fmt.Errorf("%w: %s", errFailedToRemoveFinalizer, fmt.Sprint(err))
		}

		return common.NeedToCreate, nil
	}

	// Update the status of the ServiceInstance resource in Kubernetes.
	if err := kube.Status().Update(ctx, latest); err != nil {
		return common.NothingToDo, fmt.Errorf("%w: %s", errCannotUpdateServiceInstanceStatus, fmt.Sprint(err))
	}

	return common.NothingToDo, nil
}

// handleActiveBindings checks for active ServiceBindings before allowing deletion of the ServiceInstance.
// If active bindings are found, it updates the ServiceInstance status to reflect this and prevents deletion.
// If no active bindings are found, it allows the deletion process to proceed.
// It returns an ExternalObservation indicating that the resource exists and is up to date,
// along with any error encountered during the process.
func (si *ServiceInstance) HandleDeletionWithActiveBindings(ctx context.Context, kube client.Client) error {
	// if err := c.UpdateActiveBindingsStatus(ctx, instance); err != nil {
	// 	return managed.ExternalObservation{}, fmt.Errorf("%w: %s", errCannotUpdateActiveBindingsStatus, fmt.Sprint(err))
	// }

	// Update the status of the ServiceInstance resource in Kubernetes.
	if err := kube.Status().Update(ctx, si); err != nil {
		return fmt.Errorf("%w: %s", errCannotUpdateServiceInstanceStatus, fmt.Sprint(err))
	}

	return nil
}

// UpdateActiveBindingsStatus updates the ServiceInstance status to reflect whether
// it has any active ServiceBindings in the same namespace.
// func (c *external) UpdateActiveBindingsStatus(ctx context.Context, instance *v1alpha1.ServiceInstance) error {
//	var bindingList apisbinding.ServiceBindingList
//	if err := c.kube.List(ctx, &bindingList, client.InNamespace(instance.GetNamespace())); err != nil {
//		return fmt.Errorf("%w: %s", errCannotListServiceBindings, fmt.Sprint(err))
//	}
//
//	if instance == nil {
//		return errServiceInstanceEmpty
//	}
//
//	apishelpers.SetActiveBindingsForInstance(instance, bindingList.Items)
//
//	return nil
// }

func (si *ServiceInstance) Provision(ctx context.Context, kube client.Client, osb osbClient.Client) error {
	params, err := si.Spec.ForProvider.Parameters.ToParameters()
	if err != nil {
		return fmt.Errorf("%w: %s", errParseParametersFailed, fmt.Sprint(err))
	}

	ctxMap, err := si.Spec.ForProvider.Context.ToMap()
	if err != nil {
		return fmt.Errorf("%w: %s", errParseContextFailed, fmt.Sprint(err))
	}

	req, err := si.buildProvisionRequest(params, ctxMap)
	if err != nil {
		return fmt.Errorf("%w, %s", errFailedToBuildProvisionRequest, fmt.Sprint(err))
	}

	resp, err := osb.ProvisionInstance(req)
	if err != nil {
		return fmt.Errorf("%w: %s", errOSBProvisionInstanceFailed, fmt.Sprint(err))
	}

	si.UpdateStatusFromOSB(resp)

	if err := kube.Status().Update(ctx, si); err != nil {
		return fmt.Errorf("%w: %s", errCannotUpdateServiceInstanceStatus, fmt.Sprint(err))
	}

	return nil
}

func (si *ServiceInstance) Update(ctx context.Context, kube client.Client, osb osbClient.Client, oid osbClient.OriginatingIdentity) error {
	// Build the OSB update request.
	req, err := si.buildUpdateInstanceRequest(oid)
	if err != nil {
		return fmt.Errorf("%w: %s", errCannotBuildUpdateRequest, fmt.Sprint(err))
	}

	// Send the request to the OSB broker.
	resp, err := osb.UpdateInstance(req)
	if err != nil {
		return fmt.Errorf("%w: %s", errOSBUpdateInstanceFailed, fmt.Sprint(err))
	}

	// Update the instance status based on the response.
	si.UpdateStatusFromOSB(resp)

	// Persist the updated status in Kubernetes.
	if err := kube.Status().Update(ctx, si); err != nil {
		return fmt.Errorf("%w: %s", errCannotUpdateServiceInstanceStatus, fmt.Sprint(err))
	}

	return nil
}

func (si *ServiceInstance) buildGetInstanceRequest() (*osbClient.GetInstanceRequest, error) {
	if si.Spec.ForProvider.InstanceId == "" {
		return &osbClient.GetInstanceRequest{}, errInstanceIdIsEmpty
	}

	// Build the GetInstanceRequest with the InstanceId from the ServiceInstance spec.
	return &osbClient.GetInstanceRequest{
		InstanceID: si.Spec.ForProvider.InstanceId,
		//ServiceID:  instance.Spec.ForProvider.ServiceId,
		//PlanID:     instance.Spec.ForProvider.PlanId,
	}, nil
}

// ObserveState retrieves the current state of the ServiceInstance from the OSB (Open Service Broker) service.
//
// Parameters:
//   - ctx: the context for controlling cancellation and timeouts.
//   - kube: the Kubernetes client used to fetch and update resources.
//   - osb: the OSB client used to perform the GetInstance request.
//   - oid: the originating identity to include in the request.
//
// Returns three values:
//  1. An Action indicating the next step (common.NothingToDo or common.NeedToCreate).
//  2. A pointer to the GetInstanceResponse from the broker (nil if resource does not exist or on async in-progress).
//  3. An error if any step fails.
//
// Behavior:
//  1. If the ServiceInstance is in "in-progress" or "deleting" state, polls the last operation via HandleLastOperationInProgress.
//  2. If the resource is being deleted, ensures no active bindings exist via HandleDeletionWithActiveBindings.
//  3. Builds a GetInstanceRequest and retrieves the current instance state using osb.GetInstance.
//     - If the resource does not exist externally, returns NeedToCreate.
//     - Otherwise returns the response or an error for unexpected failures.
//  4. Compares the ServiceInstance spec with the external OSB instance via CompareSpecWithOSB to determine if any action is needed.
func (si *ServiceInstance) ObserveState(
	ctx context.Context,
	kube client.Client,
	osb osbClient.Client,
	oid osbClient.OriginatingIdentity) (common.Action, *osbClient.GetInstanceResponse, error) {

	// Manage pending async operations (poll only for "in progress" state)
	if si.IsStateInProgress() || si.IsStateDeleting() {
		action, err := si.HandleLastOperationInProgress(ctx, kube, osb, oid)
		if err != nil {
			return common.NothingToDo, nil, fmt.Errorf("%w: %s", errFailedToHandleLastOperationInProgress, fmt.Sprint(err))
		}

		return action, nil, nil
	}

	// If the resource is being deleted, check for active bindings before allowing deletion.
	if !si.GetDeletionTimestamp().IsZero() {
		if err := si.HandleDeletionWithActiveBindings(ctx, kube); err != nil {
			return common.NothingToDo, nil, fmt.Errorf("%w, %s", errFailedToHandleDeletionWithActiveBindings, fmt.Sprint(err))
		}
		return common.NothingToDo, nil, nil
	}

	// Build the GetInstanceRequest with the InstanceId from the ServiceInstance spec.
	req, err := si.buildGetInstanceRequest()
	if err != nil {
		return common.NothingToDo, nil, fmt.Errorf("%w: %s", errFailedToBuildGetInstanceRequest, fmt.Sprint(err))
	}

	// Call the OSB client's GetInstance method to retrieve the current state of the instance.
	osbInstance, err := osb.GetInstance(req)
	if err != nil {
		if util.IsResourceGone(err) {
			// The resource does not exist externally â€” treat as non-existent
			return common.NeedToCreate, nil, nil
		}
		// Other errors are unexpected
		return common.NothingToDo, nil, fmt.Errorf("%w: %s", errOSBGetInstance, fmt.Sprint(err))
	}

	// Compare the uninstantiated spec from the ServiceInstance with the actual instance returned from OSB.
	action, err := si.CompareSpecWithOSB(osbInstance)
	if err != nil {
		return common.NothingToDo, nil, fmt.Errorf("%w: %s", errFailedToCompareSpecWithOSB, fmt.Sprint(err))
	}

	return action, osbInstance, nil
}
