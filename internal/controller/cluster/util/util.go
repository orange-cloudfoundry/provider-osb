package util

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"reflect"
	"slices"
	"time"

	"github.com/crossplane/crossplane-runtime/v2/pkg/meta"
	"github.com/crossplane/crossplane-runtime/v2/pkg/reconciler/managed"
	"github.com/crossplane/crossplane-runtime/v2/pkg/resource"
	osb "github.com/orange-cloudfoundry/go-open-service-broker-client/v2"
	"github.com/orange-cloudfoundry/go-open-service-broker-client/v2/fake"
	"github.com/orange-cloudfoundry/provider-osb/apis/cluster/common"
	apisv1alpha1 "github.com/orange-cloudfoundry/provider-osb/apis/cluster/v1alpha1"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

const (
	MetadataPrefix                  = "osb.provider.crossplane.io"
	AsyncAnnotation                 = MetadataPrefix + "/async"
	Iso8601dateFormat               = "2006-01-02T15:04:05.9Z"
	OriginatingIdentityPlatformName = "kubernetes"
	errRequestFailed                = "OSB %s request failed"
)

// func AddFinalizer(ctx context.Context, mg resource.Managed) error {
// 	obj, ok := mg.(*v1alpha1.ServiceBinding)
// 	if !ok {
// 		return errors.New(errNotKubernetesServiceBinding)
// 	}

// 	if meta.FinalizerExists(obj, objFinalizerName) {
// 		return nil
// 	}
// 	meta.AddFinalizer(obj, objFinalizerName)

// 	err := c.kube.Update(ctx, obj)
// 	if err != nil {
// 		return errors.Wrap(err, errAddFinalizer)
// 	}

// 	// Add finalizer to referenced resources if not exists
// 	err = c.handleRefFinalizer(ctx, obj, func(
// 		ctx context.Context, res *unstructured.Unstructured, finalizer string,
// 	) error {
// 		if !meta.FinalizerExists(res, finalizer) {
// 			meta.AddFinalizer(res, finalizer)
// 		}
// 		return nil
// 	}, false)
// 	return errors.Wrap(err, errAddFinalizer)
// }

func EndpointEqual(e1, e2 osb.Endpoint) bool {
	// Use sorted copies of the endpoint's ports slices
	// to ignore elements order
	sortedPorts1 := slices.Clone(e1.Ports)
	sortedPorts2 := slices.Clone(e2.Ports)

	slices.Sort(sortedPorts1)
	slices.Sort(sortedPorts2)

	return e1.Host == e2.Host && *e1.Protocol == *e2.Protocol && slices.Equal(sortedPorts1, sortedPorts2)
}

func VolumeMountEqual(e1, e2 osb.VolumeMount) bool {
	return reflect.DeepEqual(e1, e2)
}

func TimeNow() *string {
	res := time.Now().Format(Iso8601dateFormat)
	return &res
}

func decodeB64StringToBasicAuthConfig(s string) (osb.BasicAuthConfig, error) {
	data, err := base64.StdEncoding.DecodeString(s)
	if err != nil {
		return osb.BasicAuthConfig{}, err
	}
	jsonDecode := struct {
		User     string `json:"user"`
		Password string `json:"password"`
	}{}
	err = json.Unmarshal(data, &jsonDecode)
	if err != nil {
		return osb.BasicAuthConfig{}, err
	}
	return osb.BasicAuthConfig{
		Username: jsonDecode.User,
		Password: jsonDecode.Password,
	}, err
}

// TODO: take into account controller.options:
// - to enable OSB client alpha features
func NewOsbClient(conf apisv1alpha1.ProviderConfig, creds []byte) (osb.Client, error) {
	config := osb.DefaultClientConfiguration()
	config.URL = conf.Spec.BrokerURL
	apiVersions := osb.APIVersions()
	config.APIVersion = apiVersions[conf.Spec.OSBVersion]
	config.TimeoutSeconds = conf.Spec.Timeout

	if len(creds) > 0 {
		credsString := string(creds)
		basicAuth, err := decodeB64StringToBasicAuthConfig(credsString)
		if err != nil {
			return nil, errors.Wrap(err, "error : can't decode string into basic auth struct")
		}
		authConfig := osb.AuthConfig{
			BasicAuthConfig: &basicAuth,
		}
		config.AuthConfig = &authConfig
	}

	return osb.NewClient(config)
}

// MakeOriginatingIdentityFromValue returns an osb.OriginatingIdentity object by combining:
//   - the Platform attribute ("kubernetes")
//   - the Value attribute, generated by marshalling the common.KubernetesOSBOriginatingIdentityValue in parameter
func MakeOriginatingIdentityFromValue(val common.KubernetesOSBOriginatingIdentityValue) (*osb.OriginatingIdentity, error) {
	value, err := json.Marshal(val)
	if err != nil {
		return nil, err
	}

	return &osb.OriginatingIdentity{
		Platform: OriginatingIdentityPlatformName,
		Value:    string(value),
	}, nil
}

func AddFinalizerIfNotExists(obj metav1.Object, finalizerName string) bool {
	if !meta.FinalizerExists(obj, finalizerName) {
		meta.AddFinalizer(obj, finalizerName)
		return true
	}
	return false
}

func RemoveFinalizerIfExists(obj metav1.Object, finalizerName string) bool {
	if meta.FinalizerExists(obj, finalizerName) {
		meta.RemoveFinalizer(obj, finalizerName)
		return true
	}
	return false
}

func HandleHttpError(err error, errorType string) (managed.ExternalObservation, error, bool) {
	// Manage errors, if it's http error and 404 , then it means that the resource does not exist
	if err != nil {
		if httpErr, isHttpErr := osb.IsHTTPError(err); isHttpErr && httpErr.StatusCode == http.StatusNotFound {
			return managed.ExternalObservation{
				ResourceExists: false,
			}, nil, true
		}
		// Other errors are unexpected
		return managed.ExternalObservation{}, errors.Wrap(err, fmt.Sprintf(errRequestFailed, errorType)), true
	}
	return managed.ExternalObservation{}, nil, false
}

// TODO: actually implement an no op client, since the osb.fake client
// returns an error in every function (except if redefined)
type NoOpOsbClient fake.FakeClient

// func (c *NoOpOsbClient) GetCatalog() (*osb.CatalogResponse, error) {
// 	return nil, nil
// }

const (
	errNoProviderConfig  = "no providerConfigRef provided"
	errGetProviderConfig = "cannot get referenced ProviderConfig"
	errTrackUsage        = "cannot track ProviderConfig usage"
)

func ResolveProviderConfig(ctx context.Context, crClient client.Client, mg resource.Managed) (*apisv1alpha1.ProviderConfig, error) {
	switch managed := mg.(type) {
	case resource.ModernManaged:
		return nil, errors.New("ressource is not LegacyManaged: ModernManaged")
	case resource.LegacyManaged:
		return resolveProviderConfigLegacy(ctx, crClient, managed)
	case resource.Managed:
		return nil, errors.New("ressource is not LegacyManaged: Managed")
	default:
		return nil, errors.New("resource is not a managed")
	}
}

func legacyToModernProviderConfigSpec(pc *apisv1alpha1.ProviderConfig) (*apisv1alpha1.ProviderConfig, error) {
	// TODO(erhan): this is hacky and potentially lossy, generate or manually implement
	if pc == nil {
		return nil, nil
	}
	data, err := json.Marshal(pc)
	if err != nil {
		return nil, err
	}

	var mSpec apisv1alpha1.ProviderConfig
	err = json.Unmarshal(data, &mSpec)
	mSpec.Kind = apisv1alpha1.ProviderConfigKind
	mSpec.APIVersion = apisv1alpha1.SchemeGroupVersion.String()
	mSpec.ObjectMeta = metav1.ObjectMeta{
		Name:        pc.GetName(),
		Labels:      pc.GetLabels(),
		Annotations: pc.GetAnnotations(),
		Generation:  pc.GetGeneration(),
		UID:         pc.GetUID(),
	}
	return &mSpec, err
}

func resolveProviderConfigLegacy(ctx context.Context, client client.Client, mg resource.LegacyManaged) (*apisv1alpha1.ProviderConfig, error) {
	configRef := mg.GetProviderConfigReference()
	if configRef == nil {
		return nil, errors.New(errNoProviderConfig)
	}
	pc := &apisv1alpha1.ProviderConfig{}
	if err := client.Get(ctx, types.NamespacedName{Name: configRef.Name}, pc); err != nil {
		return nil, errors.Wrap(err, errGetProviderConfig)
	}

	t := resource.NewLegacyProviderConfigUsageTracker(client, &apisv1alpha1.ProviderConfigUsage{})
	if err := t.Track(ctx, mg); err != nil {
		return nil, errors.Wrap(err, errTrackUsage)
	}

	return legacyToModernProviderConfigSpec(pc)
}
