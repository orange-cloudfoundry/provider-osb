package util

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"time"

	xpv1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
	"github.com/crossplane/crossplane-runtime/v2/pkg/meta"
	"github.com/crossplane/crossplane-runtime/v2/pkg/resource"
	osb "github.com/orange-cloudfoundry/go-open-service-broker-client/v2"
	"github.com/orange-cloudfoundry/go-open-service-broker-client/v2/fake"
	"github.com/orange-cloudfoundry/provider-osb/apis/cluster/common"
	"github.com/orange-cloudfoundry/provider-osb/apis/cluster/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

const (
	MetadataPrefix                  = "osb.provider.crossplane.io"
	AsyncAnnotation                 = MetadataPrefix + "/async"
	Iso8601dateFormat               = "2006-01-02T15:04:05.9Z"
	OriginatingIdentityPlatformName = "kubernetes"
)

// TimeNow returns the current time formatted as an ISO 8601 string.
//
// The function returns a pointer to the formatted string.
//
// Returns:
// - *string: pointer to the current time in ISO 8601 format
func TimeNow() *string {
	res := time.Now().Format(Iso8601dateFormat)
	return &res
}

// decodeB64StringToBasicAuthConfig decodes a base64-encoded JSON string
// into an OSB BasicAuthConfig containing a username and password.
//
// The expected input is a base64-encoded JSON object with the fields:
//
//	{
//	  "user": "<username>",
//	  "password": "<password>"
//	}
//
// Parameters:
// - s: the base64-encoded string
//
// Returns:
// - osb.BasicAuthConfig: struct containing Username and Password
// - error: any error encountered during decoding or unmarshalling
func decodeB64StringToBasicAuthConfig(s string) (osb.BasicAuthConfig, error) {
	// Decode the base64 string into bytes
	data, err := base64.StdEncoding.DecodeString(s)
	if err != nil {
		return osb.BasicAuthConfig{}, err
	}

	// Temporary struct to unmarshal JSON into
	jsonDecode := struct {
		User     string `json:"user"`
		Password string `json:"password"`
	}{}

	// Unmarshal the JSON data into the temporary struct
	err = json.Unmarshal(data, &jsonDecode)
	if err != nil {
		return osb.BasicAuthConfig{}, err
	}

	// Convert to osb.BasicAuthConfig and return
	return osb.BasicAuthConfig{
		Username: jsonDecode.User,
		Password: jsonDecode.Password,
	}, nil
}

// TODO: take into account controller.options:
// - to enable OSB client alpha features
func NewOsbClient(conf v1alpha1.ProviderConfig, creds []byte) (osb.Client, error) {
	config := osb.DefaultClientConfiguration()
	config.URL = conf.Spec.BrokerURL
	apiVersions := osb.APIVersions()
	config.APIVersion = apiVersions[conf.Spec.OSBVersion]
	config.TimeoutSeconds = conf.Spec.Timeout

	if len(creds) > 0 {
		credsString := string(creds)
		basicAuth, err := decodeB64StringToBasicAuthConfig(credsString)
		if err != nil {
			return nil, fmt.Errorf("%s: %w", "can't decode string into basic auth struct", err)
		}
		authConfig := osb.AuthConfig{
			BasicAuthConfig: &basicAuth,
		}
		config.AuthConfig = &authConfig
	}

	return osb.NewClient(config)
}

// MakeOriginatingIdentityFromValue returns an osb.OriginatingIdentity object by combining:
//   - the Platform attribute ("kubernetes")
//   - the Value attribute, generated by marshalling the common.KubernetesOSBOriginatingIdentityValue in parameter
func MakeOriginatingIdentityFromValue(val common.KubernetesOSBOriginatingIdentityValue) (*osb.OriginatingIdentity, error) {
	value, err := json.Marshal(val)
	if err != nil {
		return nil, err
	}

	return &osb.OriginatingIdentity{
		Platform: OriginatingIdentityPlatformName,
		Value:    string(value),
	}, nil
}

// AddFinalizerIfNotExists adds the specified finalizer to a Kubernetes object
// if it does not already exist.
//
// Parameters:
// - obj: the Kubernetes object to update (implements metav1.Object)
// - finalizerName: the name of the finalizer to add
//
// Returns:
// - bool: true if the finalizer was added, false if it already existed
func AddFinalizerIfNotExists(obj metav1.Object, finalizerName string) bool {
	if !meta.FinalizerExists(obj, finalizerName) {
		meta.AddFinalizer(obj, finalizerName)
		return true
	}
	return false
}

// RemoveFinalizerIfExists removes the specified finalizer from a Kubernetes object
// if it exists.
//
// Parameters:
// - obj: the Kubernetes object to update (implements metav1.Object)
// - finalizerName: the name of the finalizer to remove
//
// Returns:
// - bool: true if the finalizer was removed, false if it did not exist
func RemoveFinalizerIfExists(obj metav1.Object, finalizerName string) bool {
	if meta.FinalizerExists(obj, finalizerName) {
		meta.RemoveFinalizer(obj, finalizerName)
		return true
	}
	return false
}

// IsResourceGoneError checks if the provided error is an OSB HTTP error indicating
// that the resource no longer exists (HTTP 404 Not Found or 410 Gone).
//
// Parameters:
// - err: the error returned by an OSB request
//
// Returns:
// - bool: true if the resource is gone, false otherwise
func IsResourceGone(err error) bool {
	if httpErr, isHTTP := osb.IsHTTPError(err); isHTTP {
		if httpErr.StatusCode == http.StatusGone || httpErr.StatusCode == http.StatusNotFound {
			// Resource is already gone
			return true
		}
	}
	return false
}

// TODO: actually implement an no op client, since the osb.fake client
// returns an error in every function (except if redefined)
type NoOpOsbClient fake.FakeClient

// ResolveProviderConfig resolves the ProviderConfig for a given managed resource.
//
// This function handles different types of managed resources and delegates
// resolution to the appropriate implementation.
//
// Parameters:
// - ctx: the context for request lifetime and cancellation
// - crClient: a Kubernetes client used to fetch resources
// - mg: the managed resource whose ProviderConfig is being resolved
//
// Returns:
// - *v1alpha1.ProviderConfig: the resolved ProviderConfig if successful
// - error: any error that occurs during resolution
func ResolveProviderConfig(ctx context.Context, crClient client.Client, mg resource.Managed) (*v1alpha1.ProviderConfig, error) {
	switch managed := mg.(type) {
	case resource.ModernManaged:
		// If the resource is a ModernManaged, delegate to resolveProviderConfigModern
		return nil, errors.New("resource is not LegacyManaged but ModernManaged")
	case resource.LegacyManaged:
		// LegacyManaged resources are not supported for this resolution
		return resolveProviderConfigLegacy(ctx, crClient, managed)
	case resource.Managed:
		// Base Managed resources without ModernManaged interface are also unsupported
		return nil, errors.New("resource is not LegacyManaged but Managed")
	default:
		// Any other type is invalid
		return nil, errors.New("resource is not a managed type")
	}
}

// legacyToModernProviderConfigSpec converts a legacy ProviderConfig object
// into a modern ProviderConfig spec. It serializes the legacy object to JSON
// and deserializes it back, updating the Kind, APIVersion, and ObjectMeta fields.
//
// Note: This method is potentially lossy and hacky; a proper manual conversion
// should be implemented to avoid losing important fields.
func legacyToModernProviderConfigSpec(pc *v1alpha1.ProviderConfig) (*v1alpha1.ProviderConfig, error) {
	// TODO(erhan): this is hacky and potentially lossy, generate or manually implement
	if pc == nil {
		return nil, nil
	}
	data, err := json.Marshal(pc)
	if err != nil {
		return nil, err
	}

	var mSpec v1alpha1.ProviderConfig
	err = json.Unmarshal(data, &mSpec)
	mSpec.Kind = v1alpha1.ProviderConfigKind
	mSpec.APIVersion = v1alpha1.SchemeGroupVersion.String()
	mSpec.ObjectMeta = metav1.ObjectMeta{
		Name:        pc.GetName(),
		Labels:      pc.GetLabels(),
		Annotations: pc.GetAnnotations(),
		Generation:  pc.GetGeneration(),
		UID:         pc.GetUID(),
	}
	return &mSpec, err
}

// resolveProviderConfigLegacy retrieves and converts a legacy ProviderConfig
// referenced by a LegacyManaged resource. It performs the following steps:
// 1. Validates that the resource has a ProviderConfigReference.
// 2. Fetches the referenced ProviderConfig from Kubernetes.
// 3. Tracks usage of the ProviderConfig by the managed resource.
// 4. Converts the legacy ProviderConfig to the modern internal spec format.
// Returns an error if any step fails.
func resolveProviderConfigLegacy(ctx context.Context, client client.Client, mg resource.LegacyManaged) (*v1alpha1.ProviderConfig, error) {
	configRef := mg.GetProviderConfigReference()
	if configRef == nil {
		return nil, errors.New("no providerConfigRef provided")
	}
	pc := &v1alpha1.ProviderConfig{}
	if err := client.Get(ctx, types.NamespacedName{Name: configRef.Name}, pc); err != nil {
		return nil, fmt.Errorf("%s :%w", "cannot get ProviderConfig", err)
	}

	t := resource.NewLegacyProviderConfigUsageTracker(client, &v1alpha1.ProviderConfigUsage{})
	if err := t.Track(ctx, mg); err != nil {
		return nil, fmt.Errorf("%s :%w", "cannot track ProviderConfig usage", err)
	}

	return legacyToModernProviderConfigSpec(pc)
}

// Connect creates and returns an OSB (Open Service Broker) client, the Kubernetes client,
// and the originating identity for a given managed resource.
//
// Parameters:
// - ctx: the context for managing request lifetime and cancellation
// - kubeClient: a Kubernetes client for interacting with K8s resources
// - newOsbClient: a function that takes a ProviderConfig and credentials and returns an OSB client
// - mg: the managed resource to operate on
// - oidValue: the initial originating identity value used to create the full identity
//
// Returns:
// - osb.Client: the instantiated OSB client
// - client.Client: the same Kubernetes client passed in
// - *osb.OriginatingIdentity: the originating identity object
// - error: any error that occurred during the process
func Connect(
	ctx context.Context,
	kubeClient client.Client,
	newOsbClient func(v1alpha1.ProviderConfig, []byte) (osb.Client, error),
	mg resource.Managed,
	oidValue common.KubernetesOSBOriginatingIdentityValue,
) (osb.Client, client.Client, *osb.OriginatingIdentity, error) {

	// Resolve the ProviderConfig associated with the managed resource
	pc, err := ResolveProviderConfig(ctx, kubeClient, mg)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("%s: %w", "cannot get ProviderConfig", err)
	}

	// Extract credentials from the ProviderConfig
	creds, err := resource.CommonCredentialExtractor(ctx, pc.Spec.Credentials.Source, kubeClient, pc.Spec.Credentials.CommonCredentialSelectors)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("%s: %w", "cannot get credentials", err)
	}

	// Create a new OSB client using the resolved ProviderConfig and extracted credentials
	osbclient, err := newOsbClient(*pc, creds)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("%s: %w", "cannot create new osb client", err)
	}

	// Add extra data to the originating identity from the ProviderConfig
	oidValue.Extra = &pc.Spec.OriginatingIdentityExtraData

	// Create the originating identity object
	oid, err := MakeOriginatingIdentityFromValue(oidValue)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("%s: %w", "cannot make originating identity from value", err)
	}

	// Return the OSB client, the Kubernetes client, and the originating identity
	return osbclient, kubeClient, oid, nil
}

// Predefined error for failed GET operations
var ErrCannotGetResource = errors.New("cannot get latest version of resource")

// GetLatestKubeObject retrieves the latest version of a Kubernetes object.
// obj should be a pointer to a Kubernetes object (implements client.Object).
func GetLatestKubeObject[T client.Object](ctx context.Context, kube client.Client, obj T) (T, error) {
	key := client.ObjectKey{Name: obj.GetName(), Namespace: obj.GetNamespace()}
	if err := kube.Get(ctx, key, obj); err != nil {
		return obj, fmt.Errorf("failed to get latest version of %T: %w", obj, ErrCannotGetResource)
	}
	return obj, nil
}

// LastOperationStatusSetter defines the interface for Kubernetes objects
// whose status can be updated based on the last OSB operation.
// Any object implementing this interface must provide methods to set
// the last operation state, description, and conditions.
type LastOperationStatusSetter interface {
	client.Object
	SetLastOperationState(osb.LastOperationState)
	SetLastOperationDescription(desc string)
	SetConditions(conds ...xpv1.Condition)
}

// UpdateStatusFromLastOp updates the status of any Kubernetes object
// implementing LastOperationStatusSetter based on the response from the OSB last operation.
// It sets the LastOperationState, LastOperationDescription, and updates conditions
// according to the operation state (Succeeded / Failed).
func UpdateStatusFromLastOp[T LastOperationStatusSetter](obj T, resp *osb.LastOperationResponse) {
	obj.SetLastOperationState(resp.State)
	if resp.Description != nil {
		obj.SetLastOperationDescription(*resp.Description)
	}

	switch resp.State {
	case osb.StateSucceeded:
		obj.SetConditions(xpv1.Available())
	case osb.StateFailed:
		obj.SetConditions(xpv1.Unavailable())
	}
}

// HandleAsyncStatusSetter is an interface for objects that can have their asynchronous
// operation status updated. Any type implementing this interface must also implement
// client.Object and provide methods to set the last operation state and key.
type HandleAsyncStatusSetter interface {
	client.Object
	SetLastOperationState(osb.LastOperationState)
	SetLastOperationKey(*osb.OperationKey)
}

// HandleAsyncStatus updates the status of an object when the request is asynchronous.
//
// It sets the LastOperationKey if provided and updates the LastOperationState to "InProgress".
//
// Type parameter T must implement the HandleAsyncStatusSetter interface.
func HandleAsyncStatus[T HandleAsyncStatusSetter](obj T, operationKey *osb.OperationKey) {
	// If an operation key is provided, update the object with it
	if operationKey != nil {
		obj.SetLastOperationKey(operationKey)
	}

	// Mark the object's last operation as in progress
	obj.SetLastOperationState(osb.StateInProgress)
}

// MarshalMapValues marshals all values of a map into JSON bytes.
// Returns a map of the same keys with marshaled byte slices as values.
func MarshalMapValues(input map[string]any) (map[string][]byte, error) {
	output := make(map[string][]byte, len(input))
	for k, v := range input {
		b, err := json.Marshal(v)
		if err != nil {
			return nil, fmt.Errorf("cannot marshal key %q: %w", k, err)
		}
		output[k] = b
	}
	return output, nil
}

// getCredsFromResponse serializes the credentials from an OSB BindResponse
// into a map[string][]byte suitable for Crossplane connection details.
// Returns an error if any credential cannot be marshaled to JSON.
func GetCredsFromResponse(resp *osb.BindResponse) (map[string][]byte, error) {
	creds := make(map[string][]byte, len(resp.Credentials))

	for key, value := range resp.Credentials {
		data, err := json.Marshal(value)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal credential '%s' from response: %w", key, err)
		}
		creds[key] = data
	}

	return creds, nil
}

// parseISO8601Time parses a string in ISO8601 format into a time.Time.
// Returns a wrapped error if parsing fails.
func ParseISO8601Time(value, field string) (time.Time, error) {
	t, err := time.Parse(Iso8601dateFormat, value)
	if err != nil {
		return time.Time{}, fmt.Errorf("error parsing %s time: %w", field, err)
	}
	return t, nil
}
