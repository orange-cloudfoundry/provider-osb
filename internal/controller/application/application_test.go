/*
Copyright 2025 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package application

import (
	"context"
	"fmt"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/google/go-cmp/cmp"
	"github.com/pkg/errors"
	"sigs.k8s.io/controller-runtime/pkg/client"

	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	"github.com/crossplane/crossplane-runtime/pkg/meta"
	"github.com/crossplane/crossplane-runtime/pkg/reconciler/managed"
	"github.com/crossplane/crossplane-runtime/pkg/resource"
	osb "github.com/orange-cloudfoundry/go-open-service-broker-client/v2"
	v2 "github.com/orange-cloudfoundry/go-open-service-broker-client/v2"
	osbfake "github.com/orange-cloudfoundry/go-open-service-broker-client/v2/fake"
	"github.com/orange-cloudfoundry/provider-osb/apis/application/v1alpha1"
	binding "github.com/orange-cloudfoundry/provider-osb/apis/binding/v1alpha1"
	"github.com/orange-cloudfoundry/provider-osb/apis/common"
	instance "github.com/orange-cloudfoundry/provider-osb/apis/instance/v1alpha1"
	mock "github.com/orange-cloudfoundry/provider-osb/internal/mymock"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
)

// Unlike many Kubernetes projects Crossplane does not use third party testing
// libraries, per the common Go test review comments. Crossplane encourages the
// use of table driven unit tests. The tests of the crossplane-runtime project
// are representative of the testing style Crossplane encourages.
//
// https://github.com/golang/go/wiki/TestComments
// https://github.com/crossplane/crossplane/blob/master/CONTRIBUTING.md#contributing-code

type notApplication struct {
	resource.Managed
}

var (
	basicApplication = &v1alpha1.Application{
		TypeMeta: metav1.TypeMeta{
			APIVersion: v1alpha1.SchemeGroupVersion.String(),
			Kind:       v1alpha1.ApplicationKind,
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      "basic-application",
			Namespace: "basic-namespace",
			Annotations: map[string]string{
				meta.AnnotationKeyExternalName: "basicUuid",
			},
		},
		Spec: v1alpha1.ApplicationSpec{
			ForProvider: common.ApplicationData{
				Name: "basic-name-app",
				Guid: "basic-app-guid",
				ProviderConfig: common.ProviderConfigRef{
					Name: "basic-provider-config-name",
				},
			},
			ResourceSpec: xpv1.ResourceSpec{
				ProviderConfigReference: &xpv1.Reference{
					Name: "basic-providerconfig",
				},
				ManagementPolicies: xpv1.ManagementPolicies{xpv1.ManagementActionAll},
			},
		},
		Status: v1alpha1.ApplicationStatus{
			AtProvider: v1alpha1.ApplicationObservation{
				ConfigChecksum: "old-checksum", // différent de checksumToken pour trigger ValidateAuth
			},
		},
	}
	basicCatalogServices = []osb.Service{
		{
			Name:        "mysql-db",
			ID:          "1234-5678-90",
			Description: "MySQL database service",
			Bindable:    true,
			Plans: []osb.Plan{
				{
					ID:          "plan-small",
					Name:        "small",
					Description: "Small MySQL plan",
				},
				{
					ID:          "plan-large",
					Name:        "large",
					Description: "Large MySQL plan",
				},
			},
		},
		{
			Name:        "redis-cache",
			ID:          "abcd-efgh-1234",
			Description: "Redis cache service",
			Bindable:    true,
			Plans: []osb.Plan{
				{
					ID:          "plan-cache-basic",
					Name:        "basic",
					Description: "Basic Redis cache plan",
				},
			},
		},
	}
)

func generateResponse[T osb.CatalogResponse](resp *T) error {
	if getCatalogResp, ok := any(resp).(*osb.CatalogResponse); ok {
		getCatalogResp.Services = basicCatalogServices
	}

	return nil
}

func newMockKubeClientForApplication(ctrl *gomock.Controller, app *v1alpha1.Application) client.Client {
	// Create the mock
	mockClient := mock.NewMockClient(ctrl) // NewMockClient generated by mockgen

	// Mock the Status().Update() method
	mockStatus := mock.NewMockSubResourceWriter(ctrl) // generated by mockgen
	mockStatus.
		EXPECT().
		Update(gomock.Any(), gomock.Any(), gomock.Any()).
		DoAndReturn(func(ctx context.Context, obj client.Object, opts ...client.SubResourceUpdateOption) error {
			return nil
		}).
		AnyTimes()

	mockClient.
		EXPECT().
		Status().
		Return(mockStatus).
		AnyTimes()

	mockClient.
		EXPECT().
		Get(gomock.Any(), types.NamespacedName{
			Name: "basic-provider-config-name",
		}, gomock.Any()).
		DoAndReturn(func(ctx context.Context, key client.ObjectKey, obj client.Object) error {
			// remplir obj si nécessaire, ou juste nil pour simuler succès
			return nil
		}).
		AnyTimes() // si tu veux permettre plusieurs appels
	return mockClient
}

func Test_extrenal_Observe(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	type fields struct {
		osbClient  osb.Client
		kubeClient client.Client
		checksum   string
	}

	type args struct {
		ctx context.Context
		mg  resource.Managed
	}

	type want struct {
		o   managed.ExternalObservation
		err error
	}

	cases := map[string]struct {
		fields fields
		args   args
		want   want
	}{
		"NotApplication": {
			args: args{
				mg: notApplication{},
			},
			want: want{
				o:   managed.ExternalObservation{},
				err: errors.New(errNotApplication),
			},
		},
		"GetStatusFailed": {
			args: args{
				ctx: context.Background(),
				mg:  basicApplication.DeepCopy(),
			},
			fields: fields{
				osbClient: &osbfake.FakeClient{
					StatusReaction: &osbfake.StatusReaction{
						Error: errors.New("external resource is not reachable"),
					},
				},
				kubeClient: newMockKubeClientForApplication(ctrl, basicApplication),
				checksum:   basicApplication.Status.AtProvider.ConfigChecksum,
			},
			want: want{
				o:   managed.ExternalObservation{},
				err: errors.New("external resource is not reachable"),
			},
		},
		"SetReadyConditionSuccess": {
			args: args{
				ctx: context.Background(),
				mg:  basicApplication.DeepCopy(),
			},
			fields: fields{
				osbClient: &osbfake.FakeClient{
					StatusReaction: osbfake.DynamicStatusReaction(func() (*v2.GetStatusResponse, error) {
						return &v2.GetStatusResponse{Status: "OK"}, nil
					}),
					CatalogReaction: osbfake.DynamicCatalogReaction(func() (*osb.CatalogResponse, error) {
						return &osb.CatalogResponse{}, nil
					}),
				},
				kubeClient: newMockKubeClientForApplication(ctrl, basicApplication),
				checksum:   basicApplication.Status.AtProvider.ConfigChecksum,
			},
			want: want{
				o: managed.ExternalObservation{
					ResourceExists:    true,
					ResourceUpToDate:  true,
					ConnectionDetails: managed.ConnectionDetails{},
				},
				err: nil,
			},
		},
	}
	for name, tc := range cases {
		t.Run(name, func(t *testing.T) {
			basicApplication.Status.AtProvider.ConfigChecksum = "old-checksum"
			e := external{
				osb:           tc.fields.osbClient,
				kube:          tc.fields.kubeClient,
				checksumToken: tc.fields.checksum,
			}
			got, err := e.Observe(tc.args.ctx, tc.args.mg)

			dewrappedErr := err
			for errors.Unwrap(dewrappedErr) != nil {
				dewrappedErr = errors.Unwrap(dewrappedErr)
			}

			gotErrMsg := ""
			if dewrappedErr != nil {
				gotErrMsg = dewrappedErr.Error()
			}

			wantErrMsg := ""
			if tc.want.err != nil {
				wantErrMsg = tc.want.err.Error()
			}

			if diff := cmp.Diff(wantErrMsg, gotErrMsg); diff != "" {
				t.Errorf("\n%s\ne.Observe(...): -want error, +got error:\n%s\n", name, diff)
			}

			if diff := cmp.Diff(tc.want.o, got); diff != "" {
				t.Errorf("Observe() output mismatch (-want +got):\n%s", diff)
			}
		})
	}
}

func Test_external_Create(t *testing.T) {
	type fields struct {
		osbClient osb.Client
	}

	type args struct {
		ctx context.Context
		mg  resource.Managed
	}

	type want struct {
		o   managed.ExternalCreation
		err error
	}

	cases := map[string]struct {
		fields fields
		args   args
		want   want
	}{
		"NotApplication": {
			args: args{
				mg: notApplication{},
			},
			want: want{
				o:   managed.ExternalCreation{},
				err: errors.New(errNotApplication),
			},
		},
		"IsApplication": {
			args: args{
				mg: basicApplication,
			},
			want: want{
				o: managed.ExternalCreation{
					ConnectionDetails: managed.ConnectionDetails{},
				},
			},
		},
	}
	for name, tc := range cases {
		t.Run(name, func(t *testing.T) {
			e := external{
				osb: tc.fields.osbClient,
			}
			got, err := e.Create(tc.args.ctx, tc.args.mg)

			dewrappedErr := err
			for errors.Unwrap(dewrappedErr) != nil {
				dewrappedErr = errors.Unwrap(dewrappedErr)
			}

			gotErrMsg := ""
			if dewrappedErr != nil {
				gotErrMsg = dewrappedErr.Error()
			}

			wantErrMsg := ""
			if tc.want.err != nil {
				wantErrMsg = tc.want.err.Error()
			}

			if diff := cmp.Diff(wantErrMsg, gotErrMsg); diff != "" {
				t.Errorf("\n%s\ne.Create(...): -want error, +got error:\n%s\n", name, diff)
			}

			if diff := cmp.Diff(tc.want.o, got); diff != "" {
				t.Errorf("Create() output mismatch (-want +got):\n%s", diff)
			}
		})
	}
}

func Test_external_Update(t *testing.T) {
	type fields struct {
		osbClient osb.Client
	}

	type args struct {
		ctx context.Context
		mg  resource.Managed
	}

	type want struct {
		o   managed.ExternalUpdate
		err error
	}

	cases := map[string]struct {
		fields fields
		args   args
		want   want
	}{
		"NotApplication": {
			args: args{
				mg: notApplication{},
			},
			want: want{
				o:   managed.ExternalUpdate{},
				err: errors.New(errNotApplication),
			},
		},
		"IsApplication": {
			args: args{
				mg: basicApplication,
			},
			want: want{
				o: managed.ExternalUpdate{
					ConnectionDetails: managed.ConnectionDetails{},
				},
			},
		},
	}
	for name, tc := range cases {
		t.Run(name, func(t *testing.T) {
			e := external{
				osb: tc.fields.osbClient,
			}
			got, err := e.Update(tc.args.ctx, tc.args.mg)

			dewrappedErr := err
			for errors.Unwrap(dewrappedErr) != nil {
				dewrappedErr = errors.Unwrap(dewrappedErr)
			}

			gotErrMsg := ""
			if dewrappedErr != nil {
				gotErrMsg = dewrappedErr.Error()
			}

			wantErrMsg := ""
			if tc.want.err != nil {
				wantErrMsg = tc.want.err.Error()
			}

			if diff := cmp.Diff(wantErrMsg, gotErrMsg); diff != "" {
				t.Errorf("\n%s\ne.Update(...): -want error, +got error:\n%s\n", name, diff)
			}

			if diff := cmp.Diff(tc.want.o, got); diff != "" {
				t.Errorf("Update() output mismatch (-want +got):\n%s", diff)
			}
		})
	}
}

type RequestType int

const (
	ErrorOnInstanceOnly RequestType = iota
	ErrorOnBindingOnly
	SuccessBoth
)

func newMockKubeClientForApplicationDelete(ctrl *gomock.Controller, app *v1alpha1.Application, RequestType RequestType) client.Client {
	mockClient := mock.NewMockClient(ctrl) // généré par mockgen

	// Mock pour Status().Update()
	mockStatus := mock.NewMockSubResourceWriter(ctrl)
	mockStatus.
		EXPECT().
		Update(gomock.Any(), gomock.Any(), gomock.Any()).
		DoAndReturn(func(ctx context.Context, obj client.Object, opts ...client.SubResourceUpdateOption) error {
			return nil
		}).
		AnyTimes()

	mockClient.
		EXPECT().
		Status().
		Return(mockStatus).
		AnyTimes()

	mockClient.
		EXPECT().
		List(gomock.Any(), gomock.Any(), gomock.Any()).
		DoAndReturn(func(ctx context.Context, list client.ObjectList, opts ...client.ListOption) error {
			switch l := list.(type) {
			case *instance.ServiceInstanceList:
				if RequestType == ErrorOnInstanceOnly {
					l.Items = []instance.ServiceInstance{
						{
							ObjectMeta: metav1.ObjectMeta{
								Name:      "si-1",
								Namespace: app.Namespace,
							},
							Spec: instance.ServiceInstanceSpec{
								ForProvider: common.InstanceData{
									ApplicationData: &common.ApplicationData{
										Name: "basic-application",
									},
								},
							},
						},
					}
				}
				if RequestType == SuccessBoth {
					l.Items = []instance.ServiceInstance{
						{
							ObjectMeta: metav1.ObjectMeta{
								Name:      "si-1",
								Namespace: app.Namespace,
							},
							Spec: instance.ServiceInstanceSpec{
								ForProvider: common.InstanceData{
									ApplicationData: &common.ApplicationData{
										Name: "basic-name-app",
									},
								},
							},
						},
					}
				}
			case *binding.ServiceBindingList:
				if RequestType == ErrorOnBindingOnly {
					l.Items = []binding.ServiceBinding{
						{
							ObjectMeta: metav1.ObjectMeta{
								Name:      "bs-1",
								Namespace: app.Namespace,
							},
							Spec: binding.ServiceBindingSpec{
								ForProvider: binding.ServiceBindingParameters{
									ApplicationData: &common.ApplicationData{
										Name: "basic-application",
									},
								},
							},
						},
					}
				}
				if RequestType == SuccessBoth {
					l.Items = []binding.ServiceBinding{
						{
							ObjectMeta: metav1.ObjectMeta{
								Name:      "bs-1",
								Namespace: app.Namespace,
							},
							Spec: binding.ServiceBindingSpec{
								ForProvider: binding.ServiceBindingParameters{
									ApplicationData: &common.ApplicationData{
										Name: "basic-name-app",
									},
								},
							},
						},
					}
				}
			default:
				return fmt.Errorf("unsupported list type %T", list)
			}
			return nil
		}).
		AnyTimes()

	mockClient.
		EXPECT().
		Get(gomock.Any(), gomock.Any(), gomock.Any()).
		DoAndReturn(func(ctx context.Context, key client.ObjectKey, obj client.Object) error {
			return nil
		}).
		AnyTimes()

	return mockClient
}

func Test_external_Delete(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	type fields struct {
		osbClient  osb.Client
		kubeClient client.Client
	}

	type args struct {
		ctx context.Context
		mg  resource.Managed
	}

	type want struct {
		o   managed.ExternalDelete
		err error
	}

	cases := map[string]struct {
		fields fields
		args   args
		want   want
	}{
		"NotApplication": {
			args: args{
				mg: notApplication{},
			},
			want: want{
				o:   managed.ExternalDelete{},
				err: errors.New(errNotApplication),
			},
		},
		"ErrorOnInstance": {
			args: args{
				mg: basicApplication.DeepCopy(),
			},
			fields: fields{
				kubeClient: newMockKubeClientForApplicationDelete(ctrl, basicApplication.DeepCopy(), ErrorOnInstanceOnly),
			},
			want: want{
				o:   managed.ExternalDelete{},
				err: errors.New("cannot delete Application basic-application because ServiceInstance si-1 references it"),
			},
		},
		"ErrorOnBinding": {
			args: args{
				mg: basicApplication.DeepCopy(),
			},
			fields: fields{
				kubeClient: newMockKubeClientForApplicationDelete(ctrl, basicApplication.DeepCopy(), ErrorOnBindingOnly),
			},
			want: want{
				o:   managed.ExternalDelete{},
				err: errors.New("cannot delete Application basic-application because ServiceBinding bs-1 references it"),
			},
		},
		"Success": {
			args: args{
				mg: basicApplication.DeepCopy(),
			},
			fields: fields{
				kubeClient: newMockKubeClientForApplicationDelete(ctrl, basicApplication.DeepCopy(), SuccessBoth),
			},
			want: want{
				o:   managed.ExternalDelete{},
				err: nil,
			},
		},
	}
	for name, tc := range cases {
		t.Run(name, func(t *testing.T) {
			e := external{
				osb:  tc.fields.osbClient,
				kube: tc.fields.kubeClient,
			}
			got, err := e.Delete(tc.args.ctx, tc.args.mg)

			dewrappedErr := err
			for errors.Unwrap(dewrappedErr) != nil {
				dewrappedErr = errors.Unwrap(dewrappedErr)
			}

			gotErrMsg := ""
			if dewrappedErr != nil {
				gotErrMsg = dewrappedErr.Error()
			}

			wantErrMsg := ""
			if tc.want.err != nil {
				wantErrMsg = tc.want.err.Error()
			}

			if diff := cmp.Diff(wantErrMsg, gotErrMsg); diff != "" {
				t.Errorf("\n%s\ne.Delete(...): -want error, +got error:\n%s\n", name, diff)
			}

			if diff := cmp.Diff(tc.want.o, got); diff != "" {
				t.Errorf("Delete() output mismatch (-want +got):\n%s", diff)
			}
		})
	}
}

func Test_external_Disconnect(t *testing.T) {
	type fields struct {
		osbClient osb.Client
	}

	type args struct {
		ctx context.Context
		mg  resource.Managed
	}

	type want struct {
		o   managed.ExternalDelete
		err error
	}

	cases := map[string]struct {
		fields fields
		args   args
		want   want
	}{
		"Undefined": {},
	}
	for name, tc := range cases {
		t.Run(name, func(t *testing.T) {
			e := external{
				osb: tc.fields.osbClient,
			}
			err := e.Disconnect(tc.args.ctx)

			dewrappedErr := err
			for errors.Unwrap(dewrappedErr) != nil {
				dewrappedErr = errors.Unwrap(dewrappedErr)
			}

			gotErrMsg := ""
			if dewrappedErr != nil {
				gotErrMsg = dewrappedErr.Error()
			}

			wantErrMsg := ""
			if tc.want.err != nil {
				wantErrMsg = tc.want.err.Error()
			}

			if diff := cmp.Diff(wantErrMsg, gotErrMsg); diff != "" {
				t.Errorf("\n%s\ne.Delete(...): -want error, +got error:\n%s\n", name, diff)
			}
		})
	}
}
