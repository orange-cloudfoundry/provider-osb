package util

import (
	"encoding/base64"
	"encoding/json"
	"reflect"
	"slices"
	"time"

	"github.com/crossplane/crossplane-runtime/pkg/meta"
	osb "github.com/orange-cloudfoundry/go-open-service-broker-client/v2"
	"github.com/orange-cloudfoundry/go-open-service-broker-client/v2/fake"
	"github.com/orange-cloudfoundry/provider-osb/apis/common"
	apisv1alpha1 "github.com/orange-cloudfoundry/provider-osb/apis/v1alpha1"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
	MetadataPrefix                  = "osb.provider.crossplane.io"
	AsyncAnnotation                 = MetadataPrefix + "/async"
	Iso8601dateFormat               = "2006-01-02T15:04:05.9Z"
	OriginatingIdentityPlatformName = "kubernetes"
)

// func AddFinalizer(ctx context.Context, mg resource.Managed) error {
// 	obj, ok := mg.(*v1alpha1.ServiceBinding)
// 	if !ok {
// 		return errors.New(errNotKubernetesServiceBinding)
// 	}

// 	if meta.FinalizerExists(obj, objFinalizerName) {
// 		return nil
// 	}
// 	meta.AddFinalizer(obj, objFinalizerName)

// 	err := c.kube.Update(ctx, obj)
// 	if err != nil {
// 		return errors.Wrap(err, errAddFinalizer)
// 	}

// 	// Add finalizer to referenced resources if not exists
// 	err = c.handleRefFinalizer(ctx, obj, func(
// 		ctx context.Context, res *unstructured.Unstructured, finalizer string,
// 	) error {
// 		if !meta.FinalizerExists(res, finalizer) {
// 			meta.AddFinalizer(res, finalizer)
// 		}
// 		return nil
// 	}, false)
// 	return errors.Wrap(err, errAddFinalizer)
// }

func EndpointEqual(e1, e2 osb.Endpoint) bool {
	// Use sorted copies of the endpoint's ports slices
	// to ignore elements order
	sortedPorts1 := slices.Clone(e1.Ports)
	sortedPorts2 := slices.Clone(e2.Ports)

	slices.Sort(sortedPorts1)
	slices.Sort(sortedPorts2)

	return e1.Host == e2.Host && *e1.Protocol == *e2.Protocol && slices.Equal(sortedPorts1, sortedPorts2)
}

func VolumeMountEqual(e1, e2 osb.VolumeMount) bool {
	return reflect.DeepEqual(e1, e2)
}

func TimeNow() *string {
	res := time.Now().Format(Iso8601dateFormat)
	return &res
}

func decodeB64StringToBasicAuthConfig(s string) (osb.BasicAuthConfig, error) {
	data, err := base64.StdEncoding.DecodeString(s)
	if err != nil {
		return osb.BasicAuthConfig{}, err
	}
	jsonDecode := struct {
		User     string `json:"user"`
		Password string `json:"password"`
	}{}
	err = json.Unmarshal(data, &jsonDecode)
	if err != nil {
		return osb.BasicAuthConfig{}, err
	}
	return osb.BasicAuthConfig{
		Username: jsonDecode.User,
		Password: jsonDecode.Password,
	}, err
}

// TODO: take into account controller.options:
// - to enable OSB client alpha features
func NewOsbClient(conf apisv1alpha1.ProviderConfig, creds []byte) (osb.Client, error) {
	config := osb.DefaultClientConfiguration()
	config.URL = conf.Spec.BrokerURL
	apiVersions := osb.APIVersions()
	config.APIVersion = apiVersions[conf.Spec.OSBVersion]
	config.TimeoutSeconds = conf.Spec.Timeout

	if len(creds) > 0 {
		credsString := string(creds)
		basicAuth, err := decodeB64StringToBasicAuthConfig(credsString)
		if err != nil {
			return nil, errors.Wrap(err, "error : can't decode string into basic auth struct")
		}
		authConfig := osb.AuthConfig{
			BasicAuthConfig: &basicAuth,
		}
		config.AuthConfig = &authConfig
	}

	return osb.NewClient(config)
}

// MakeOriginatingIdentityFromValue returns an osb.OriginatingIdentity object by combining:
//   - the Platform attribute ("kubernetes")
//   - the Value attribute, generated by marshalling the common.KubernetesOSBOriginatingIdentityValue in parameter
func MakeOriginatingIdentityFromValue(val common.KubernetesOSBOriginatingIdentityValue) (*osb.OriginatingIdentity, error) {
	value, err := json.Marshal(val)
	if err != nil {
		return nil, err
	}

	return &osb.OriginatingIdentity{
		Platform: OriginatingIdentityPlatformName,
		Value:    string(value),
	}, nil
}

func AddFinalizerIfNotExists(obj metav1.Object, finalizerName string) bool {
	if !meta.FinalizerExists(obj, finalizerName) {
		meta.AddFinalizer(obj, finalizerName)
		return true
	}
	return false
}

func RemoveFinalizerIfExists(obj metav1.Object, finalizerName string) bool {
	if meta.FinalizerExists(obj, finalizerName) {
		meta.RemoveFinalizer(obj, finalizerName)
		return true
	}
	return false
}

// TODO: actually implement an no op client, since the osb.fake client
// returns an error in every function (except if redefined)
type NoOpOsbClient fake.FakeClient

// func (c *NoOpOsbClient) GetCatalog() (*osb.CatalogResponse, error) {
// 	return nil, nil
// }

// StructToMap convertit une struct en map[string]interface{}
func StructToMap(obj interface{}) map[string]interface{} {
	result := make(map[string]interface{})
	val := reflect.ValueOf(obj)
	typ := reflect.TypeOf(obj)

	// VÃ©rifie si l'objet est une struct
	if val.Kind() == reflect.Ptr {
		val = val.Elem()
		typ = typ.Elem()
	}
	if val.Kind() != reflect.Struct {
		return result
	}

	for i := 0; i < val.NumField(); i++ {
		field := val.Field(i)
		fieldType := typ.Field(i)
		// Utilise le tag json si disponible, sinon le nom du champ
		key := fieldType.Tag.Get("json")
		if key == "" {
			key = fieldType.Name
		}
		result[key] = field.Interface()
	}
	return result
}
