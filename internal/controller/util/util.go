package util

import (
	"context"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"net/http"
	"reflect"
	"slices"
	"time"

	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	"github.com/crossplane/crossplane-runtime/pkg/meta"
	"github.com/crossplane/crossplane-runtime/pkg/reconciler/managed"
	osb "github.com/orange-cloudfoundry/go-open-service-broker-client/v2"
	"github.com/orange-cloudfoundry/go-open-service-broker-client/v2/fake"
	"github.com/orange-cloudfoundry/provider-osb/apis/common"
	apisv1alpha1 "github.com/orange-cloudfoundry/provider-osb/apis/v1alpha1"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

const (
	MetadataPrefix                  = "osb.provider.crossplane.io"
	AsyncAnnotation                 = MetadataPrefix + "/async"
	Iso8601dateFormat               = "2006-01-02T15:04:05.9Z"
	OriginatingIdentityPlatformName = "kubernetes"
	errRequestFailed                = "OSB %s request failed"
)

// func AddFinalizer(ctx context.Context, mg resource.Managed) error {
// 	obj, ok := mg.(*v1alpha1.ServiceBinding)
// 	if !ok {
// 		return errors.New(errNotKubernetesServiceBinding)
// 	}

// 	if meta.FinalizerExists(obj, objFinalizerName) {
// 		return nil
// 	}
// 	meta.AddFinalizer(obj, objFinalizerName)

// 	err := c.kube.Update(ctx, obj)
// 	if err != nil {
// 		return errors.Wrap(err, errAddFinalizer)
// 	}

// 	// Add finalizer to referenced resources if not exists
// 	err = c.handleRefFinalizer(ctx, obj, func(
// 		ctx context.Context, res *unstructured.Unstructured, finalizer string,
// 	) error {
// 		if !meta.FinalizerExists(res, finalizer) {
// 			meta.AddFinalizer(res, finalizer)
// 		}
// 		return nil
// 	}, false)
// 	return errors.Wrap(err, errAddFinalizer)
// }

func EndpointEqual(e1, e2 osb.Endpoint) bool {
	// Use sorted copies of the endpoint's ports slices
	// to ignore elements order
	sortedPorts1 := slices.Clone(e1.Ports)
	sortedPorts2 := slices.Clone(e2.Ports)

	slices.Sort(sortedPorts1)
	slices.Sort(sortedPorts2)

	return e1.Host == e2.Host && *e1.Protocol == *e2.Protocol && slices.Equal(sortedPorts1, sortedPorts2)
}

func VolumeMountEqual(e1, e2 osb.VolumeMount) bool {
	return reflect.DeepEqual(e1, e2)
}

func TimeNow() *string {
	res := time.Now().Format(Iso8601dateFormat)
	return &res
}

func decodeB64StringToBasicAuthConfig(s string) (osb.BasicAuthConfig, error) {
	data, err := base64.StdEncoding.DecodeString(s)
	if err != nil {
		return osb.BasicAuthConfig{}, err
	}
	jsonDecode := struct {
		User     string `json:"user"`
		Password string `json:"password"`
	}{}
	err = json.Unmarshal(data, &jsonDecode)
	if err != nil {
		return osb.BasicAuthConfig{}, err
	}
	return osb.BasicAuthConfig{
		Username: jsonDecode.User,
		Password: jsonDecode.Password,
	}, err
}

// TODO: take into account controller.options:
// - to enable OSB client alpha features
func NewOsbClient(conf apisv1alpha1.ProviderConfig, creds []byte) (osb.Client, error) {
	config := osb.DefaultClientConfiguration()
	config.URL = conf.Spec.BrokerURL
	apiVersions := osb.APIVersions()
	config.APIVersion = apiVersions[conf.Spec.OSBVersion]
	config.TimeoutSeconds = conf.Spec.Timeout

	if len(creds) > 0 {
		credsString := string(creds)
		basicAuth, err := decodeB64StringToBasicAuthConfig(credsString)
		if err != nil {
			return nil, errors.Wrap(err, "error : can't decode string into basic auth struct")
		}
		authConfig := osb.AuthConfig{
			BasicAuthConfig: &basicAuth,
		}
		config.AuthConfig = &authConfig
	}

	return osb.NewClient(config)
}

// MakeOriginatingIdentityFromValue returns an osb.OriginatingIdentity object by combining:
//   - the Platform attribute ("kubernetes")
//   - the Value attribute, generated by marshalling the common.KubernetesOSBOriginatingIdentityValue in parameter
func MakeOriginatingIdentityFromValue(val common.KubernetesOSBOriginatingIdentityValue) (*osb.OriginatingIdentity, error) {
	value, err := json.Marshal(val)
	if err != nil {
		return nil, err
	}

	return &osb.OriginatingIdentity{
		Platform: OriginatingIdentityPlatformName,
		Value:    string(value),
	}, nil
}

func AddFinalizerIfNotExists(obj metav1.Object, finalizerName string) bool {
	if !meta.FinalizerExists(obj, finalizerName) {
		meta.AddFinalizer(obj, finalizerName)
		return true
	}
	return false
}

func RemoveFinalizerIfExists(obj metav1.Object, finalizerName string) bool {
	if meta.FinalizerExists(obj, finalizerName) {
		meta.RemoveFinalizer(obj, finalizerName)
		return true
	}
	return false
}

func HandleHttpError(err error, errorType string) (managed.ExternalObservation, error, bool) {
	// Manage errors, if it's http error and 404 , then it means that the resource does not exist
	if err != nil {
		if httpErr, isHttpErr := osb.IsHTTPError(err); isHttpErr && httpErr.StatusCode == http.StatusNotFound {
			return managed.ExternalObservation{
				ResourceExists: false,
			}, nil, true
		}
		// Other errors are unexpected
		return managed.ExternalObservation{}, errors.Wrap(err, fmt.Sprintf(errRequestFailed, errorType)), true
	}
	return managed.ExternalObservation{}, nil, false
}

// TODO: actually implement an no op client, since the osb.fake client
// returns an error in every function (except if redefined)
type NoOpOsbClient fake.FakeClient

// func (c *NoOpOsbClient) GetCatalog() (*osb.CatalogResponse, error) {
// 	return nil, nil
// }

func GetProviderConfig(ctx context.Context, kube client.Client, ref common.ProviderConfigRef) (*apisv1alpha1.ProviderConfig, error) {
	pc := &apisv1alpha1.ProviderConfig{}
	key := client.ObjectKey{Name: ref.Name}
	if err := kube.Get(ctx, key, pc); err != nil {
		return nil, err
	}

	return pc, nil
}

func HashBytes(b []byte) string {
	h := sha256.Sum256(b)
	return hex.EncodeToString(h[:])
}

func ValidateAuth(osb osb.Client) error {
	_, err := osb.GetCatalog()
	if err != nil {
		return errors.Wrap(err, "authentication failed")
	}
	return nil
}

type MetaObject interface {
	client.Object
	GetConfigChecksum() string
	SetConfigChecksum(string)
	GetCondition(condType xpv1.ConditionType) xpv1.Condition
	SetConditions(conditions ...xpv1.Condition)
}

func IsConfigChanged[T MetaObject](cr T, newChecksum string) bool {
	return cr.GetConfigChecksum() != newChecksum
}

func EnsureConfigChecksum[T MetaObject](ctx context.Context, kube client.Client, cr T, newChecksum string) (bool, error) {
	if cr.GetConfigChecksum() == newChecksum {
		return false, nil
	}

	cr.SetConfigChecksum(newChecksum)

	if err := kube.Status().Update(ctx, cr); err != nil {
		return false, errors.Wrap(err, "cannot update status with new ConfigChecksum")
	}

	return true, nil
}

func IsBrokerAvailable[T MetaObject](ctx context.Context, osb osb.Client, kube client.Client, cr T) error {
	_, err := osb.GetStatus()
	if err != nil {
		cr.SetConditions(xpv1.Available().WithMessage("external resource is not reachable"))

		if err := kube.Status().Update(ctx, cr); err != nil {
			return errors.Wrap(err, "cannot update status")
		}
		return errors.Wrap(err, "external resource is not reachable")
	}
	return nil
}

func SetReadyCondition[T MetaObject](ctx context.Context, kube client.Client, cr T, message string) error {
	condition := cr.GetCondition(xpv1.TypeReady)

	if condition.Status != "True" {
		cr.SetConditions(xpv1.Available().WithMessage(message))

		if err := kube.Status().Update(ctx, cr); err != nil {
			return errors.Wrap(err, "cannot update status")
		}
	}

	return nil
}

// CheckOSBBrokerResource checks the availability of the OSB broker, ensures the configuration checksum,
// validates authentication if needed, and updates the Ready condition.
// Returns true if an update is required, or an error if any step fails.
func CheckOSBBrokerResource[T MetaObject](ctx context.Context, osb osb.Client, kube client.Client, cr T, checksumToken string) (needsUpdate bool, err error) {
	// Broker availability
	if err := IsBrokerAvailable(ctx, osb, kube, cr); err != nil {
		return false, fmt.Errorf("OSB broker unavailable: %w", err)
	}

	// Ensure config checksum
	needsUpdate, err = EnsureConfigChecksum(ctx, kube, cr, checksumToken)
	if err != nil {
		return false, fmt.Errorf("failed to ensure config checksum: %w", err)
	}

	// Validate auth if needed
	if needsUpdate {
		if err := ValidateAuth(osb); err != nil {
			return false, fmt.Errorf("OSB authentication validation failed: %w", err)
		}
	}

	// Set Ready condition
	if err := SetReadyCondition(ctx, kube, cr, "The external resource is reachable and authentication is valid"); err != nil {
		return false, fmt.Errorf("failed to set Ready condition: %w", err)
	}

	return needsUpdate, nil
}
