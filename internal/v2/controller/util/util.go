package util

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"reflect"
	"slices"
	"time"

	"github.com/crossplane/crossplane-runtime/v2/pkg/meta"
	"github.com/crossplane/crossplane-runtime/v2/pkg/reconciler/managed"
	osb "github.com/orange-cloudfoundry/go-open-service-broker-client/v2"
	"github.com/orange-cloudfoundry/go-open-service-broker-client/v2/fake"
	"github.com/orange-cloudfoundry/provider-osb/apis/v2/common"
	apisv1alpha1 "github.com/orange-cloudfoundry/provider-osb/apis/v2/v1alpha1"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
	MetadataPrefix                  = "osb.provider.crossplane.io"
	AsyncAnnotation                 = MetadataPrefix + "/async"
	Iso8601dateFormat               = "2006-01-02T15:04:05.9Z"
	OriginatingIdentityPlatformName = "kubernetes"
	errRequestFailed                = "OSB %s request failed"
)

// func AddFinalizer(ctx context.Context, mg resource.Managed) error {
// 	obj, ok := mg.(*v1alpha1.ServiceBinding)
// 	if !ok {
// 		return errors.New(errNotKubernetesServiceBinding)
// 	}

// 	if meta.FinalizerExists(obj, objFinalizerName) {
// 		return nil
// 	}
// 	meta.AddFinalizer(obj, objFinalizerName)

// 	err := c.kube.Update(ctx, obj)
// 	if err != nil {
// 		return errors.Wrap(err, errAddFinalizer)
// 	}

// 	// Add finalizer to referenced resources if not exists
// 	err = c.handleRefFinalizer(ctx, obj, func(
// 		ctx context.Context, res *unstructured.Unstructured, finalizer string,
// 	) error {
// 		if !meta.FinalizerExists(res, finalizer) {
// 			meta.AddFinalizer(res, finalizer)
// 		}
// 		return nil
// 	}, false)
// 	return errors.Wrap(err, errAddFinalizer)
// }

func EndpointEqual(e1, e2 osb.Endpoint) bool {
	// Use sorted copies of the endpoint's ports slices
	// to ignore elements order
	sortedPorts1 := slices.Clone(e1.Ports)
	sortedPorts2 := slices.Clone(e2.Ports)

	slices.Sort(sortedPorts1)
	slices.Sort(sortedPorts2)

	return e1.Host == e2.Host && *e1.Protocol == *e2.Protocol && slices.Equal(sortedPorts1, sortedPorts2)
}

func VolumeMountEqual(e1, e2 osb.VolumeMount) bool {
	return reflect.DeepEqual(e1, e2)
}

func TimeNow() *string {
	res := time.Now().Format(Iso8601dateFormat)
	return &res
}

func decodeB64StringToBasicAuthConfig(s string) (osb.BasicAuthConfig, error) {
	data, err := base64.StdEncoding.DecodeString(s)
	if err != nil {
		return osb.BasicAuthConfig{}, err
	}
	jsonDecode := struct {
		User     string `json:"user"`
		Password string `json:"password"`
	}{}
	err = json.Unmarshal(data, &jsonDecode)
	if err != nil {
		return osb.BasicAuthConfig{}, err
	}
	return osb.BasicAuthConfig{
		Username: jsonDecode.User,
		Password: jsonDecode.Password,
	}, err
}

// TODO: take into account controller.options:
// - to enable OSB client alpha features
func NewOsbClient(conf apisv1alpha1.ProviderConfig, creds []byte) (osb.Client, error) {
	config := osb.DefaultClientConfiguration()
	config.URL = conf.Spec.BrokerURL
	apiVersions := osb.APIVersions()
	config.APIVersion = apiVersions[conf.Spec.OSBVersion]
	config.TimeoutSeconds = conf.Spec.Timeout

	if len(creds) > 0 {
		credsString := string(creds)
		basicAuth, err := decodeB64StringToBasicAuthConfig(credsString)
		if err != nil {
			return nil, errors.Wrap(err, "error : can't decode string into basic auth struct")
		}
		authConfig := osb.AuthConfig{
			BasicAuthConfig: &basicAuth,
		}
		config.AuthConfig = &authConfig
	}

	return osb.NewClient(config)
}

// MakeOriginatingIdentityFromValue returns an osb.OriginatingIdentity object by combining:
//   - the Platform attribute ("kubernetes")
//   - the Value attribute, generated by marshalling the common.KubernetesOSBOriginatingIdentityValue in parameter
func MakeOriginatingIdentityFromValue(val common.KubernetesOSBOriginatingIdentityValue) (*osb.OriginatingIdentity, error) {
	value, err := json.Marshal(val)
	if err != nil {
		return nil, err
	}

	return &osb.OriginatingIdentity{
		Platform: OriginatingIdentityPlatformName,
		Value:    string(value),
	}, nil
}

func AddFinalizerIfNotExists(obj metav1.Object, finalizerName string) bool {
	if !meta.FinalizerExists(obj, finalizerName) {
		meta.AddFinalizer(obj, finalizerName)
		return true
	}
	return false
}

func RemoveFinalizerIfExists(obj metav1.Object, finalizerName string) bool {
	if meta.FinalizerExists(obj, finalizerName) {
		meta.RemoveFinalizer(obj, finalizerName)
		return true
	}
	return false
}

func HandleHttpError(err error, errorType string) (managed.ExternalObservation, error, bool) {
	// Manage errors, if it's http error and 404 , then it means that the resource does not exist
	if err != nil {
		if httpErr, isHttpErr := osb.IsHTTPError(err); isHttpErr && httpErr.StatusCode == http.StatusNotFound {
			return managed.ExternalObservation{
				ResourceExists: false,
			}, nil, true
		}
		// Other errors are unexpected
		return managed.ExternalObservation{}, errors.Wrap(err, fmt.Sprintf(errRequestFailed, errorType)), true
	}
	return managed.ExternalObservation{}, nil, false
}

// TODO: actually implement an no op client, since the osb.fake client
// returns an error in every function (except if redefined)
type NoOpOsbClient fake.FakeClient

// func (c *NoOpOsbClient) GetCatalog() (*osb.CatalogResponse, error) {
// 	return nil, nil
// }
